export type NumType = number | bigint;
export declare const isNumType: (x: any) => x is NumType;
export type BytesType = Uint8Array;
export declare const isBytesType: (x: any) => x is Uint8Array;
export type PrimitiveType = NumType | BytesType;
export declare const isPrimitiveType: (x: any) => x is PrimitiveType;
export type BinaryLiterals = "int" | "uint" | "bytes" | "array" | "object" | "switch";
export type Endianness = "little" | "big";
export type NumberSize = 1 | 2 | 3 | 4 | 5 | 6;
export declare const numberMaxSize = 6;
export type NumSizeToPrimitive<Size extends number> = Size extends NumberSize ? number : bigint;
export type FixedConversion<FromType extends PrimitiveType, ToType> = {
    readonly to: ToType;
    readonly from: FromType;
};
export type CustomConversion<FromType extends PrimitiveType, ToType> = {
    readonly to: (val: FromType) => ToType;
    readonly from: (val: ToType) => FromType;
};
interface LayoutItemBase<BL extends BinaryLiterals> {
    readonly binary: BL;
}
interface FixedPrimitiveCustom<T extends PrimitiveType> {
    custom: T;
    omit?: boolean;
}
interface OptionalToFromCustom<T extends PrimitiveType> {
    custom?: FixedConversion<T, any> | CustomConversion<T, any>;
}
interface NumLayoutItemBase<T extends NumType, Signed extends Boolean> extends LayoutItemBase<Signed extends true ? "int" : "uint"> {
    size: T extends bigint ? number : NumberSize;
    endianness?: Endianness;
}
export interface FixedPrimitiveNumLayoutItem<T extends NumType, Signed extends Boolean> extends NumLayoutItemBase<T, Signed>, FixedPrimitiveCustom<T> {
}
export interface OptionalToFromNumLayoutItem<T extends NumType, Signed extends Boolean> extends NumLayoutItemBase<T, Signed>, OptionalToFromCustom<T> {
}
export interface FixedPrimitiveBytesLayoutItem extends LayoutItemBase<"bytes">, FixedPrimitiveCustom<BytesType> {
}
export interface FixedValueBytesLayoutItem extends LayoutItemBase<"bytes"> {
    readonly custom: FixedConversion<BytesType, any>;
}
export interface FixedSizeBytesLayoutItem extends LayoutItemBase<"bytes"> {
    readonly size: number;
    readonly custom?: CustomConversion<BytesType, any>;
}
export interface LengthPrefixedBytesLayoutItem extends LayoutItemBase<"bytes"> {
    readonly lengthSize?: NumberSize;
    readonly lengthEndianness?: Endianness;
    readonly custom?: CustomConversion<BytesType, any>;
}
interface ArrayLayoutItemBase extends LayoutItemBase<"array"> {
    readonly layout: Layout;
}
export interface FixedSizeArrayLayoutItem extends ArrayLayoutItemBase {
    readonly length: number;
}
export interface LengthPrefixedArrayLayoutItem extends ArrayLayoutItemBase {
    readonly lengthSize?: NumberSize;
    readonly lengthEndianness?: Endianness;
}
export interface ObjectLayoutItem extends LayoutItemBase<"object"> {
    readonly layout: ProperLayout;
}
type PlainId = number;
type ConversionId = readonly [number, unknown];
type IdProperLayoutPair<Id extends PlainId | ConversionId, P extends ProperLayout = ProperLayout> = readonly [Id, P];
type IdProperLayoutPairs = readonly IdProperLayoutPair<PlainId>[] | readonly IdProperLayoutPair<ConversionId>[];
export interface SwitchLayoutItem extends LayoutItemBase<"switch"> {
    readonly idSize: NumberSize;
    readonly idTag?: string;
    readonly idEndianness?: Endianness;
    readonly layouts: IdProperLayoutPairs;
}
export type NumLayoutItem<Signed extends boolean = boolean> = Signed extends infer S extends boolean ? FixedPrimitiveNumLayoutItem<number, S> | OptionalToFromNumLayoutItem<number, S> | FixedPrimitiveNumLayoutItem<bigint, S> | OptionalToFromNumLayoutItem<bigint, S> : never;
export type UintLayoutItem = NumLayoutItem<false>;
export type IntLayoutItem = NumLayoutItem<true>;
export type BytesLayoutItem = FixedPrimitiveBytesLayoutItem | FixedValueBytesLayoutItem | FixedSizeBytesLayoutItem | LengthPrefixedBytesLayoutItem;
export type ArrayLayoutItem = FixedSizeArrayLayoutItem | LengthPrefixedArrayLayoutItem;
export type LayoutItem = NumLayoutItem | BytesLayoutItem | ArrayLayoutItem | ObjectLayoutItem | SwitchLayoutItem;
export type NamedLayoutItem = LayoutItem & {
    readonly name: string;
};
export type ProperLayout = readonly NamedLayoutItem[];
export type Layout = LayoutItem | ProperLayout;
type NameOrOmitted<T extends {
    name: string;
}> = T extends {
    omit: true;
} ? never : T["name"];
export type LayoutToType<L extends Layout> = L extends infer LI extends LayoutItem ? LayoutItemToType<LI> : L extends infer P extends ProperLayout ? {
    readonly [I in P[number] as NameOrOmitted<I>]: LayoutItemToType<I>;
} : never;
type MaybeConvert<Id extends PlainId | ConversionId> = Id extends readonly [number, infer Converted] ? Converted : Id;
type IdLayoutPairsToTypeUnion<A extends IdProperLayoutPairs, IdTag extends string> = A extends infer V extends IdProperLayoutPairs ? V extends readonly [infer Head, ...infer Tail extends IdProperLayoutPairs] ? Head extends IdProperLayoutPair<infer MaybeConversionId, infer P extends ProperLayout> ? MaybeConvert<MaybeConversionId> extends infer Id ? LayoutToType<P> extends infer LT extends object ? {
    readonly [K in IdTag | keyof LT]: K extends keyof LT ? LT[K] : Id;
} | IdLayoutPairsToTypeUnion<Tail, IdTag> : never : never : never : never : never;
export type LayoutItemToType<Item extends LayoutItem> = Item extends infer I extends LayoutItem ? I extends NumLayoutItem ? I["custom"] extends NumType ? I["custom"] : I["custom"] extends CustomConversion<infer FromType extends NumType, infer ToType> ? ToType : I["custom"] extends FixedConversion<infer FromType extends NumType, infer ToType> ? ToType : NumSizeToPrimitive<I["size"]> : I extends BytesLayoutItem ? I["custom"] extends CustomConversion<BytesType, infer ToType> ? ToType : I["custom"] extends FixedConversion<BytesType, infer ToType> ? ToType : BytesType : I extends ArrayLayoutItem ? readonly LayoutToType<I["layout"]>[] : I extends ObjectLayoutItem ? LayoutToType<I["layout"]> : I extends SwitchLayoutItem ? IdLayoutPairsToTypeUnion<I["layouts"], I["idTag"] extends string ? I["idTag"] : "id"> : never : never;
export {};
//# sourceMappingURL=layout.d.ts.map