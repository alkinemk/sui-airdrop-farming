"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toChain = exports.toChainId = exports.asChainId = exports.assertChain = exports.assertChainId = exports.isChainId = exports.isChain = exports.chainIdToChain = exports.chainToChainId = exports.chainIds = exports.chains = void 0;
const utils_1 = require("../utils");
const mapping_1 = require("../utils/mapping");
// prettier-ignore
const chainsAndChainIdEntries = [
    //Unlike the old sdk, we are not including an "Unset" chain with chainId 0 here because:
    //  * no other types would be associated with it (such as contracts or a platform)
    //  * avoids awkward "chain but not 'Unset'" checks
    //  * "off" is not a TV channel either
    //Instead we'll use `null` for chain and 0 as the chainId where appropriate (e.g. governance VAAs)
    ["Solana", 1],
    ["Ethereum", 2],
    ["Terra", 3],
    ["Bsc", 4],
    ["Polygon", 5],
    ["Avalanche", 6],
    ["Oasis", 7],
    ["Algorand", 8],
    ["Aurora", 9],
    ["Fantom", 10],
    ["Karura", 11],
    ["Acala", 12],
    ["Klaytn", 13],
    ["Celo", 14],
    ["Near", 15],
    ["Moonbeam", 16],
    ["Neon", 17],
    ["Terra2", 18],
    ["Injective", 19],
    ["Osmosis", 20],
    ["Sui", 21],
    ["Aptos", 22],
    ["Arbitrum", 23],
    ["Optimism", 24],
    ["Gnosis", 25],
    ["Pythnet", 26],
    ["Xpla", 28],
    ["Btc", 29],
    ["Base", 30],
    ["Sei", 32],
    ["Rootstock", 33],
    ["Wormchain", 3104],
    ["Cosmoshub", 4000],
    ["Evmos", 4001],
    ["Kujira", 4002],
    ["Sepolia", 10002],
    ["ArbitrumSepolia", 10003],
    ["BaseSepolia", 10004],
    ["OptimismSepolia", 10005],
    ["Holesky", 10006],
];
_a = (0, utils_1.zip)(chainsAndChainIdEntries), exports.chains = _a[0], exports.chainIds = _a[1];
exports.chainToChainId = (0, mapping_1.constMap)(chainsAndChainIdEntries);
exports.chainIdToChain = (0, mapping_1.constMap)(chainsAndChainIdEntries, [1, 0]);
const isChain = (chain) => exports.chainToChainId.has(chain);
exports.isChain = isChain;
const isChainId = (chainId) => exports.chainIdToChain.has(chainId);
exports.isChainId = isChainId;
function assertChainId(chainId) {
    if (!(0, exports.isChainId)(chainId))
        throw Error(`Unknown Wormhole chain id: ${chainId}`);
}
exports.assertChainId = assertChainId;
function assertChain(chain) {
    if (!(0, exports.isChain)(chain))
        throw Error(`Unknown Wormhole chain: ${chain}`);
}
exports.assertChain = assertChain;
//safe assertion that allows chaining
const asChainId = (chainId) => {
    assertChainId(chainId);
    return chainId;
};
exports.asChainId = asChainId;
const toChainId = (chain) => {
    switch (typeof chain) {
        case "string":
            if ((0, exports.isChain)(chain))
                return (0, exports.chainToChainId)(chain);
            break;
        case "number":
            if ((0, exports.isChainId)(chain))
                return chain;
            break;
    }
    throw Error(`Cannot convert to ChainId: ${chain}`);
};
exports.toChainId = toChainId;
const toChain = (chain) => {
    switch (typeof chain) {
        case "string":
            if ((0, exports.isChain)(chain))
                return chain;
            break;
        case "number":
            if ((0, exports.isChainId)(chain))
                return (0, exports.chainIdToChain)(chain);
            break;
        case "bigint":
            if ((0, exports.isChainId)(Number(chain)))
                return (0, exports.chainIdToChain)(Number(chain));
            break;
    }
    throw Error(`Cannot convert to Chain: ${chain}`);
};
exports.toChain = toChain;
//# sourceMappingURL=chains.js.map