"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenByAddress = exports.getCanonicalToken = exports.getNativeToken = exports.getTokenByKey = exports.getTokensBySymbol = exports.isEqualCaseInsensitive = exports.getTokenMap = void 0;
//import { mainnetTokenDetails } from "./mainnetTokenDetails";
//import { testnetTokenDetails } from "./testnetTokenDetails";
const mainnet_1 = require("./mainnet");
const testnet_1 = require("./testnet");
__exportStar(require("./types"), exports);
function getTokenMap(network, chain) {
    if (network === "Devnet")
        return;
    if (network === "Mainnet") {
        if (!mainnet_1.mainnetChainTokens.has(chain))
            return;
        const chainTokens = mainnet_1.mainnetChainTokens.get(chain);
        return Object.fromEntries(chainTokens.map(([key, token]) => [key, { ...token, chain, key }]));
    }
    if (network === "Testnet") {
        if (!testnet_1.testnetChainTokens.has(chain))
            return;
        const chainTokens = testnet_1.testnetChainTokens.get(chain);
        return Object.fromEntries(chainTokens.map(([key, token]) => [key, { ...token, chain, key }]));
    }
    throw "Unsupported network: " + network;
}
exports.getTokenMap = getTokenMap;
const isEqualCaseInsensitive = (a, b) => {
    return a.toLowerCase() === b.toLowerCase();
};
exports.isEqualCaseInsensitive = isEqualCaseInsensitive;
function getTokensBySymbol(network, chain, symbol) {
    const tokenMap = getTokenMap(network, chain);
    if (!tokenMap)
        return;
    const foundTokens = Object.entries(tokenMap)
        .filter(([_, token]) => token.symbol === symbol)
        .map((t) => t[1]);
    if (!foundTokens || foundTokens.length === 0)
        return;
    return foundTokens;
}
exports.getTokensBySymbol = getTokensBySymbol;
function getTokenByKey(network, chain, key) {
    const tokenMap = getTokenMap(network, chain);
    if (!tokenMap)
        return;
    const foundToken = Object.entries(tokenMap).find(([_key]) => key === _key);
    if (!foundToken)
        return;
    return foundToken[1];
}
exports.getTokenByKey = getTokenByKey;
function getNativeToken(network, chain) {
    const tokenMap = getTokenMap(network, chain);
    if (!tokenMap)
        return;
    const nativeTokenEntry = Object.entries(tokenMap).find(([, token]) => token.address === "native");
    if (!nativeTokenEntry)
        return;
    return nativeTokenEntry[1];
}
exports.getNativeToken = getNativeToken;
function getCanonicalToken(network, chain, key) {
    const token = getTokenByKey(network, chain, key);
    if (!token)
        return;
    if (!token.original)
        return token;
    const original = getTokensBySymbol(network, token.original, token.symbol);
    if (!original)
        return;
    // return the the token with this symbol where no `original` field exists
    return original.find((t) => !t.original);
}
exports.getCanonicalToken = getCanonicalToken;
// Finds the unique token key for a given chain and address
function getTokenByAddress(network, chain, address) {
    const tokenMap = getTokenMap(network, chain);
    if (!tokenMap)
        return;
    const foundToken = Object.entries(tokenMap).find(([, token]) => (0, exports.isEqualCaseInsensitive)(token.address, address));
    if (!foundToken)
        return;
    return foundToken[1];
}
exports.getTokenByAddress = getTokenByAddress;
//# sourceMappingURL=index.js.map