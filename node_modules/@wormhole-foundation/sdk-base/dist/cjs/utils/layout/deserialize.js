"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeLayout = void 0;
const layout_1 = require("./layout");
const utils_1 = require("./utils");
function deserializeLayout(layout, encoded, offset, consumeAll) {
    const [decoded, finalOffset] = internalDeserializeLayout(layout, encoded, offset ?? 0);
    if ((consumeAll ?? true) && finalOffset !== encoded.length)
        throw new Error(`encoded data is longer than expected: ${encoded.length} > ${finalOffset}`);
    return (consumeAll ?? true ? decoded : [decoded, finalOffset]);
}
exports.deserializeLayout = deserializeLayout;
function internalDeserializeLayout(layout, encoded, offset) {
    if (!Array.isArray(layout))
        return deserializeLayoutItem(layout, encoded, offset);
    let decoded = {};
    for (const item of layout)
        try {
            [(item.omit ? {} : decoded)[item.name], offset] =
                deserializeLayoutItem(item, encoded, offset);
        }
        catch (e) {
            e.message = `when deserializing item '${item.name}': ${e.message}`;
            throw e;
        }
    return [decoded, offset];
}
function updateOffset(encoded, offset, size) {
    const newOffset = offset + size;
    if (newOffset > encoded.length)
        throw new Error(`encoded data is shorter than expected: ${encoded.length} < ${newOffset}`);
    return newOffset;
}
function deserializeNum(encoded, offset, bytes, endianness = "big", signed = false) {
    let val = 0n;
    for (let i = 0; i < bytes; ++i)
        val |= BigInt(encoded[offset + i]) << BigInt(8 * (endianness === "big" ? bytes - i - 1 : i));
    //check sign bit if value is indeed signed and adjust accordingly
    if (signed && (encoded[offset + (endianness === "big" ? 0 : bytes - 1)] & 0x80))
        val -= 1n << BigInt(8 * bytes);
    return [
        ((bytes > layout_1.numberMaxSize) ? val : Number(val)),
        updateOffset(encoded, offset, bytes)
    ];
}
function deserializeLayoutItem(item, encoded, offset) {
    switch (item.binary) {
        case "int":
        case "uint": {
            const [value, newOffset] = deserializeNum(encoded, offset, item.size, item.endianness, item.binary === "int");
            if ((0, layout_1.isNumType)(item.custom)) {
                (0, utils_1.checkNumEquals)(item.custom, value);
                return [item.custom, newOffset];
            }
            if ((0, layout_1.isNumType)(item?.custom?.from)) {
                (0, utils_1.checkNumEquals)(item.custom.from, value);
                return [item.custom.to, newOffset];
            }
            return [
                item.custom !== undefined ? item.custom.to(value) : value,
                newOffset
            ];
        }
        case "bytes": {
            let newOffset;
            let fixedFrom;
            let fixedTo;
            if (item.custom !== undefined) {
                if ((0, layout_1.isBytesType)(item.custom))
                    fixedFrom = item.custom;
                else if ((0, layout_1.isBytesType)(item.custom.from)) {
                    fixedFrom = item.custom.from;
                    fixedTo = item.custom.to;
                }
            }
            if (fixedFrom !== undefined)
                newOffset = updateOffset(encoded, offset, fixedFrom.length);
            else {
                item = item;
                if ("size" in item && item.size !== undefined)
                    newOffset = updateOffset(encoded, offset, item.size);
                else if ("lengthSize" in item && item.lengthSize !== undefined) {
                    let length;
                    [length, offset] =
                        deserializeNum(encoded, offset, item.lengthSize, item.lengthEndianness);
                    newOffset = updateOffset(encoded, offset, length);
                }
                else
                    newOffset = encoded.length;
            }
            const value = encoded.slice(offset, newOffset);
            if (fixedFrom !== undefined) {
                (0, utils_1.checkUint8ArrayDeeplyEqual)(fixedFrom, value);
                return [fixedTo ?? fixedFrom, newOffset];
            }
            return [
                item.custom !== undefined ? item.custom.to(value) : value,
                newOffset
            ];
        }
        case "array": {
            let ret = [];
            const { layout } = item;
            const deserializeArrayItem = () => {
                const [deserializedItem, newOffset] = internalDeserializeLayout(layout, encoded, offset);
                ret.push(deserializedItem);
                offset = newOffset;
            };
            let length = null;
            if ("length" in item)
                length = item.length;
            else if (item.lengthSize !== undefined)
                [length, offset] =
                    deserializeNum(encoded, offset, item.lengthSize, item.lengthEndianness);
            if (length !== null)
                for (let i = 0; i < length; ++i)
                    deserializeArrayItem();
            else
                while (offset < encoded.length)
                    deserializeArrayItem();
            return [ret, offset];
        }
        case "object": {
            return internalDeserializeLayout(item.layout, encoded, offset);
        }
        case "switch": {
            const [id, newOffset] = deserializeNum(encoded, offset, item.idSize, item.idEndianness);
            const { layouts } = item;
            if (layouts.length === 0)
                throw new Error(`switch item has no layouts`);
            const hasPlainIds = typeof layouts[0][0] === "number";
            const pair = layouts.find(([idOrConversionId]) => hasPlainIds ? idOrConversionId === id : (idOrConversionId)[0] === id);
            if (pair === undefined)
                throw new Error(`unknown id value: ${id}`);
            const [idOrConversionId, idLayout] = pair;
            const [decoded, nextOffset] = internalDeserializeLayout(idLayout, encoded, newOffset);
            return [
                { [item.idTag ?? "id"]: hasPlainIds ? id : idOrConversionId[1],
                    ...decoded },
                nextOffset
            ];
        }
    }
}
//# sourceMappingURL=deserialize.js.map