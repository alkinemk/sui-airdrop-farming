import { Chain, ChainToPlatform, Network, Platform } from "@wormhole-foundation/sdk-base";
import { Attestation, AttestationId, AttestationReceipt, AutomaticCircleBridge, ChainContext, CircleMessageId, CircleTransferDetails, Signer, TransactionId, TxHash, WormholeMessageId } from "@wormhole-foundation/sdk-definitions";
import { Wormhole } from "../wormhole";
import { AttestedTransferReceipt, CompletedTransferReceipt, SourceFinalizedTransferReceipt, TransferQuote, TransferReceipt, TransferState, WormholeTransfer } from "../wormholeTransfer";
type CircleTransferProtocol = "CircleBridge" | "AutomaticCircleBridge";
export declare class CircleTransfer<N extends Network = Network> implements WormholeTransfer<CircleTransferProtocol> {
    private readonly wh;
    fromChain: ChainContext<N, Platform, Chain>;
    toChain: ChainContext<N, Platform, Chain>;
    private _state;
    transfer: CircleTransferDetails;
    txids: TransactionId[];
    attestations?: AttestationReceipt<CircleTransferProtocol>[];
    private constructor();
    getTransferState(): TransferState;
    static from<N extends Network>(wh: Wormhole<N>, from: CircleTransferDetails, timeout?: number, fromChain?: ChainContext<N, Platform, Chain>, toChain?: ChainContext<N, Platform, Chain>): Promise<CircleTransfer<N>>;
    static from<N extends Network>(wh: Wormhole<N>, from: WormholeMessageId, timeout?: number, fromChain?: ChainContext<N, Platform, Chain>, toChain?: ChainContext<N, Platform, Chain>): Promise<CircleTransfer<N>>;
    static from<N extends Network>(wh: Wormhole<N>, from: string, // CircleMessage hex encoded
    timeout?: number, fromChain?: ChainContext<N, Platform, Chain>, toChain?: ChainContext<N, Platform, Chain>): Promise<CircleTransfer<N>>;
    static from<N extends Network>(wh: Wormhole<N>, from: TransactionId, timeout?: number, fromChain?: ChainContext<N, Platform, Chain>, toChain?: ChainContext<N, Platform, Chain>): Promise<CircleTransfer<N>>;
    private static fromWormholeMessageId;
    private static fromCircleMessage;
    private static fromTransaction;
    initiateTransfer(signer: Signer): Promise<TxHash[]>;
    private _fetchWormholeAttestation;
    private _fetchCircleAttestation;
    fetchAttestation(timeout?: number): Promise<AttestationId[]>;
    completeTransfer(signer: Signer): Promise<TxHash[]>;
    static quoteTransfer<N extends Network>(srcChain: ChainContext<N, Platform, Chain>, dstChain: ChainContext<N, Platform, Chain>, transfer: CircleTransferDetails): Promise<TransferQuote>;
    static isTransferComplete<N extends Network>(toChain: ChainContext<N, Platform, Chain>, attestation: Attestation<CircleTransferProtocol>): Promise<boolean>;
    static getTransferVaa<N extends Network>(wh: Wormhole<N>, wormholeMessageId: WormholeMessageId, timeout?: number): Promise<AutomaticCircleBridge.VAA>;
    static getTransferMessage<N extends Network>(fromChain: ChainContext<N, Platform, Chain>, txid: TxHash): Promise<CircleMessageId>;
    static getReceipt<N extends Network>(xfer: CircleTransfer<N>): TransferReceipt<CircleTransferProtocol>;
    static track<N extends Network, SC extends Chain, DC extends Chain>(wh: Wormhole<N>, receipt: TransferReceipt<CircleTransferProtocol, SC, DC>, timeout?: number, _fromChain?: ChainContext<N, ChainToPlatform<SC>, SC>, _toChain?: ChainContext<N, ChainToPlatform<DC>, DC>): AsyncGenerator<SourceFinalizedTransferReceipt<CircleTransferProtocol, SC, DC> | AttestedTransferReceipt<CircleTransferProtocol, SC, DC> | CompletedTransferReceipt<CircleTransferProtocol, SC, DC>, void, unknown>;
}
export {};
//# sourceMappingURL=cctpTransfer.d.ts.map