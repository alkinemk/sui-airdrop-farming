import { Chain, Network } from "@wormhole-foundation/sdk-base";
import { ChainContext, Signer, TokenId, TransactionId } from "@wormhole-foundation/sdk-definitions";
import { Wormhole } from "../wormhole";
import { RouteTransferRequest } from "./request";
import { Options, Quote, Receipt, TransferParams, ValidatedTransferParams, ValidationResult } from "./types";
export type UnknownRouteConstructor<N extends Network> = RouteConstructor<N>;
export type RouteConstructor<N extends Network> = {
    new (wh: Wormhole<N>, request: RouteTransferRequest<N>): UnknownRoute<N>;
    supportedNetworks(): Network[];
    supportedChains(network: Network): Chain[];
    supportedSourceTokens(fromChain: ChainContext<Network>): Promise<(TokenId | "native")[]>;
    supportedDestinationTokens<N extends Network>(token: TokenId, fromChain: ChainContext<N>, toChain: ChainContext<N>): Promise<(TokenId | "native")[]>;
    isProtocolSupported<N extends Network>(fromChain: ChainContext<N>, toChain: ChainContext<N>): boolean;
};
export type UnknownRoute<N extends Network, OP extends Options = Options, R extends Receipt = Receipt, Q extends Quote = Quote> = Route<N, OP, R, Q>;
export declare abstract class Route<N extends Network, OP extends Options = Options, R extends Receipt = Receipt, Q extends Quote = Quote> {
    wh: Wormhole<N>;
    request: RouteTransferRequest<N>;
    abstract readonly NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    abstract readonly IS_AUTOMATIC: boolean;
    constructor(wh: Wormhole<N>, request: RouteTransferRequest<N>);
    abstract validate(params: TransferParams<OP>): Promise<ValidationResult<OP>>;
    abstract initiate(sender: Signer, params: ValidatedTransferParams<OP>): Promise<R>;
    abstract quote(params: ValidatedTransferParams<OP>): Promise<Q>;
    abstract track(receipt: R, timeout?: number): AsyncGenerator<R>;
    abstract getDefaultOptions(): OP;
}
export declare abstract class AutomaticRoute<N extends Network, OP extends Options = Options, R extends Receipt = Receipt, Q extends Quote = Quote> extends Route<N, OP, R, Q> {
    IS_AUTOMATIC: boolean;
    abstract isAvailable(): Promise<boolean>;
}
export declare function isAutomatic<N extends Network>(route: UnknownRoute<N>): route is AutomaticRoute<N>;
export declare abstract class ManualRoute<N extends Network, OP extends Options = Options, R extends Receipt = Receipt, Q extends Quote = Quote> extends Route<N, OP, R, Q> {
    NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    IS_AUTOMATIC: boolean;
    abstract complete(sender: Signer, receipt: R): Promise<TransactionId[]>;
}
export declare function isManual<N extends Network>(route: UnknownRoute<N>): route is ManualRoute<N>;
//# sourceMappingURL=route.d.ts.map