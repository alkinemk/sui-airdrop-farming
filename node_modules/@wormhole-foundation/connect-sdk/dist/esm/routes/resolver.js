import { resolveWrappedToken } from "@wormhole-foundation/sdk-definitions";
import { isAutomatic } from "./route";
export class RouteResolver {
    wh;
    routeConstructors;
    inputTokenList;
    constructor(wh, routeConstructors) {
        this.wh = wh;
        this.routeConstructors = routeConstructors;
    }
    async supportedSourceTokens(chain) {
        // TODO: make this a set to dedupe?
        this.inputTokenList =
            this.inputTokenList ??
                (await Promise.all(this.routeConstructors.flatMap(async (rc) => rc.supportedSourceTokens(chain)))).flat();
        return this.inputTokenList;
    }
    async supportedDestinationTokens(inputToken, fromChain, toChain) {
        const [, inputTokenId] = resolveWrappedToken(fromChain.network, fromChain.chain, inputToken);
        const tokens = await Promise.all(this.routeConstructors.map(async (rc) => rc.supportedDestinationTokens(inputTokenId, fromChain, toChain)));
        return tokens.flat();
    }
    async findRoutes(request) {
        const matches = await Promise.all(this.routeConstructors
            .filter((rc) => rc.supportedNetworks().includes(this.wh.network) &&
            rc.supportedChains(this.wh.network).includes(request.to.chain) &&
            rc.supportedChains(this.wh.network).includes(request.from.chain) &&
            rc.isProtocolSupported(request.fromChain, request.toChain))
            .map((rc) => new rc(this.wh, request))
            .map(async (route) => {
            const match = isAutomatic(route) ? await route.isAvailable() : true;
            return [match, match ? route : undefined];
        }));
        return matches.filter(([match]) => match).map(([, route]) => route);
    }
    async sortRoutes(routes, sortBy) {
        // TODO: actually sort
        return routes;
    }
}
//# sourceMappingURL=resolver.js.map