import { AttestationReceipt, Chain, ChainContext, Network, PorticoBridge, Signer, SourceInitiatedTransferReceipt, TokenId, TransactionId, TransferQuote, TransferState } from "../..";
import { AutomaticRoute } from "../route";
import { Receipt, TransferParams, ValidatedTransferParams, ValidationResult } from "../types";
export declare const SLIPPAGE_BPS = 15n;
export declare const BPS_PER_HUNDRED_PERCENT = 10000n;
export declare namespace PorticoRoute {
    type Options = {};
    interface Quote extends TransferQuote {
        quote: PorticoBridge.Quote;
    }
    type NormalizedParams = {
        amount: bigint;
        canonicalSourceToken: TokenId;
        canonicalDestinationToken: TokenId;
        sourceToken: TokenId;
        destinationToken: TokenId;
    };
    interface ValidatedParams extends ValidatedTransferParams<Options> {
        normalizedParams: NormalizedParams;
        quote?: Quote;
    }
}
type Q = PorticoRoute.Quote;
type OP = PorticoRoute.Options;
type R = Receipt<AttestationReceipt<"PorticoBridge">>;
type VP = PorticoRoute.ValidatedParams;
type VR = ValidationResult<OP>;
type TP = TransferParams<OP>;
export declare class AutomaticPorticoRoute<N extends Network> extends AutomaticRoute<N, OP, R, Q> {
    NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    static readonly _supportedTokens: string[];
    static supportedNetworks(): Network[];
    static supportedChains(network: Network): Chain[];
    static supportedSourceTokens(fromChain: ChainContext<Network>): Promise<(TokenId | "native")[]>;
    static supportedDestinationTokens<N extends Network>(sourceToken: TokenId, fromChain: ChainContext<N>, toChain: ChainContext<N>): Promise<(TokenId | "native")[]>;
    static isProtocolSupported<N extends Network>(fromChain: ChainContext<N>, toChain: ChainContext<N>): boolean;
    isAvailable(): Promise<boolean>;
    getDefaultOptions(): OP;
    validate(params: TP): Promise<VR>;
    quote(params: VP): Promise<Q>;
    initiate(sender: Signer<N>, params: VP): Promise<SourceInitiatedTransferReceipt<"Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Acala" | "Arbitrum" | "Aurora" | "Avalanche" | "Base" | "Bsc" | "Celo" | "Ethereum" | "Fantom" | "Gnosis" | "Karura" | "Klaytn" | "Moonbeam" | "Neon" | "Oasis" | "Optimism" | "Polygon" | "Rootstock" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "Pythnet" | "Cosmoshub" | "Evmos" | "Injective" | "Kujira" | "Osmosis" | "Sei" | "Terra" | "Terra2" | "Wormchain" | "Xpla", "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Acala" | "Arbitrum" | "Aurora" | "Avalanche" | "Base" | "Bsc" | "Celo" | "Ethereum" | "Fantom" | "Gnosis" | "Karura" | "Klaytn" | "Moonbeam" | "Neon" | "Oasis" | "Optimism" | "Polygon" | "Rootstock" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "Pythnet" | "Cosmoshub" | "Evmos" | "Injective" | "Kujira" | "Osmosis" | "Sei" | "Terra" | "Terra2" | "Wormchain" | "Xpla">>;
    track(receipt: R, timeout?: number): AsyncGenerator<{
        vaa: import("@wormhole-foundation/sdk-definitions/dist/esm/vaa/vaa").VAA<"TokenBridge:TransferWithPayload">;
        parsed: {
            readonly flagSet: {
                readonly recipientChain: number;
                readonly bridgeNonce: number;
                readonly feeTierStart: number;
                readonly feeTierFinish: number;
                readonly padding: Uint8Array;
                readonly flags: import("@wormhole-foundation/sdk-base/dist/esm/utils/layout/items").Bitset<readonly ["shouldWrapNative", "shouldUnwrapNative"]>;
            };
            readonly finalTokenAddress: import("@wormhole-foundation/sdk-definitions/dist/esm/universalAddress").UniversalAddress;
            readonly recipientAddress: import("@wormhole-foundation/sdk-definitions/dist/esm/universalAddress").UniversalAddress;
            readonly cannonAssetAmount: bigint;
            readonly minAmountFinish: bigint;
            readonly relayerFee: bigint;
        };
        state: TransferState.SourceInitiated;
        originTxs: TransactionId<"Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Acala" | "Arbitrum" | "Aurora" | "Avalanche" | "Base" | "Bsc" | "Celo" | "Ethereum" | "Fantom" | "Gnosis" | "Karura" | "Klaytn" | "Moonbeam" | "Neon" | "Oasis" | "Optimism" | "Polygon" | "Rootstock" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "Pythnet" | "Cosmoshub" | "Evmos" | "Injective" | "Kujira" | "Osmosis" | "Sei" | "Terra" | "Terra2" | "Wormchain" | "Xpla">[];
        from: "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Acala" | "Arbitrum" | "Aurora" | "Avalanche" | "Base" | "Bsc" | "Celo" | "Ethereum" | "Fantom" | "Gnosis" | "Karura" | "Klaytn" | "Moonbeam" | "Neon" | "Oasis" | "Optimism" | "Polygon" | "Rootstock" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "Pythnet" | "Cosmoshub" | "Evmos" | "Injective" | "Kujira" | "Osmosis" | "Sei" | "Terra" | "Terra2" | "Wormchain" | "Xpla";
        to: "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Acala" | "Arbitrum" | "Aurora" | "Avalanche" | "Base" | "Bsc" | "Celo" | "Ethereum" | "Fantom" | "Gnosis" | "Karura" | "Klaytn" | "Moonbeam" | "Neon" | "Oasis" | "Optimism" | "Polygon" | "Rootstock" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "Pythnet" | "Cosmoshub" | "Evmos" | "Injective" | "Kujira" | "Osmosis" | "Sei" | "Terra" | "Terra2" | "Wormchain" | "Xpla";
    }, void, unknown>;
    complete(signer: Signer<N>, receipt: R): Promise<TransactionId[]>;
    private quoteUniswap;
}
export {};
//# sourceMappingURL=automatic.d.ts.map