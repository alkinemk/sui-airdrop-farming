import { circle, contracts } from "@wormhole-foundation/sdk-base";
import { CircleTransfer } from "../../protocols/cctpTransfer";
import { TransferState } from "../../types";
import { AutomaticRoute } from "../route";
import { Wormhole } from "../../wormhole";
export class AutomaticCCTPRoute extends AutomaticRoute {
    NATIVE_GAS_DROPOFF_SUPPORTED = true;
    static supportedNetworks() {
        return ["Mainnet", "Testnet"];
    }
    // get the list of chains this route supports
    static supportedChains(network) {
        if (contracts.circleContractChains.has(network)) {
            return contracts.circleContractChains.get(network);
        }
        return [];
    }
    // get the list of source tokens that are possible to send
    static async supportedSourceTokens(fromChain) {
        const { network, chain } = fromChain;
        if (!circle.usdcContract.has(network, chain))
            return [];
        return [Wormhole.chainAddress(chain, circle.usdcContract.get(network, chain))];
    }
    // get the liist of destination tokens that may be recieved on the destination chain
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        const { network, chain } = toChain;
        if (!circle.usdcContract.has(network, chain))
            return [];
        return ["native", Wormhole.chainAddress(chain, circle.usdcContract.get(network, chain))];
    }
    static isProtocolSupported(fromChain, toChain) {
        return fromChain.supportsAutomaticCircleBridge() && toChain.supportsAutomaticCircleBridge();
    }
    getDefaultOptions() {
        return {
            nativeGas: 0.0,
        };
    }
    async isAvailable() {
        return true;
    }
    async validate(params) {
        try {
            const options = params.options ?? this.getDefaultOptions();
            const normalizedParams = await this.normalizeTransferParams(params);
            if (normalizedParams.amount <= 0n) {
                return {
                    valid: false,
                    params,
                    error: new Error("Amount must be positive"),
                };
            }
            const validatedParams = {
                normalizedParams,
                options,
                ...params,
            };
            return { valid: true, params: validatedParams };
        }
        catch (e) {
            return {
                valid: false,
                params,
                error: e,
            };
        }
    }
    async quote(params) {
        return await CircleTransfer.quoteTransfer(this.request.fromChain, this.request.toChain, this.toTransferDetails(params));
    }
    async normalizeTransferParams(params) {
        const amount = this.request.normalizeAmount(params.amount);
        const ctb = await this.request.fromChain.getAutomaticCircleBridge();
        const fee = await ctb.getRelayerFee(this.request.to.chain);
        const minAmount = (fee * 105n) / 100n;
        if (amount < minAmount) {
            throw new Error(`Minimum amount is ${this.request.displayAmount(minAmount)}`);
        }
        const transferableAmount = amount - fee;
        const options = params.options ?? this.getDefaultOptions();
        const nativeGasPerc = options.nativeGas ?? 0.0;
        if (nativeGasPerc > 1.0 || nativeGasPerc < 0.0)
            throw new Error("Native gas must be between 0.0 and 1.0 (0% and 100%)");
        let nativeGasAmount = 0n;
        if (nativeGasPerc > 0.0) {
            const scale = 10000;
            const scaledGas = BigInt(nativeGasPerc * scale);
            nativeGasAmount = (transferableAmount * scaledGas) / BigInt(scale);
        }
        return { fee, amount, nativeGasAmount };
    }
    toTransferDetails(params) {
        return {
            from: this.request.from,
            to: this.request.to,
            amount: params.normalizedParams.amount,
            automatic: true,
            nativeGas: params.normalizedParams.nativeGasAmount,
        };
    }
    async initiate(signer, params) {
        let transfer = this.toTransferDetails(params);
        let txids = await CircleTransfer.transfer(this.request.fromChain, transfer, signer);
        const msg = await CircleTransfer.getTransferMessage(this.request.fromChain, txids[txids.length - 1].txid);
        return {
            from: transfer.from.chain,
            to: transfer.to.chain,
            state: TransferState.SourceFinalized,
            originTxs: txids,
            attestation: { id: msg.id, attestation: { message: msg.message } },
        };
    }
    async *track(receipt, timeout) {
        yield* CircleTransfer.track(this.wh, receipt, timeout, this.request.fromChain, this.request.toChain);
    }
}
//# sourceMappingURL=automatic.js.map