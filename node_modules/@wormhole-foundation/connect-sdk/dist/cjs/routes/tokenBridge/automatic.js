"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomaticTokenBridgeRoute = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const tokenTransfer_1 = require("../../protocols/tokenTransfer");
const types_1 = require("../../types");
const route_1 = require("../route");
class AutomaticTokenBridgeRoute extends route_1.AutomaticRoute {
    NATIVE_GAS_DROPOFF_SUPPORTED = true;
    static supportedNetworks() {
        return ["Mainnet", "Testnet"];
    }
    // get the list of chains this route supports
    static supportedChains(network) {
        if (sdk_base_1.contracts.tokenBridgeRelayerChains.has(network)) {
            return sdk_base_1.contracts.tokenBridgeRelayerChains.get(network);
        }
        return [];
    }
    // get the list of source tokens that are possible to send
    static async supportedSourceTokens(fromChain) {
        const atb = await fromChain.getAutomaticTokenBridge();
        const registered = await atb.getRegisteredTokens();
        return [
            "native",
            ...registered.map((v) => {
                return { chain: fromChain.chain, address: v };
            }),
        ];
    }
    // get the liist of destination tokens that may be recieved on the destination chain
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        return ["native", await tokenTransfer_1.TokenTransfer.lookupDestinationToken(fromChain, toChain, sourceToken)];
    }
    static isProtocolSupported(fromChain, toChain) {
        return fromChain.supportsAutomaticTokenBridge() && toChain.supportsAutomaticTokenBridge();
    }
    getDefaultOptions() {
        return { nativeGas: 0.0 };
    }
    async isSupported() {
        try {
            // No transfers to same chain
            if (this.request.fromChain.chain === this.request.toChain.chain)
                return false;
            // No transfers to unsupported chains
            if (!this.request.fromChain.supportsAutomaticTokenBridge())
                return false;
            if (!this.request.toChain.supportsAutomaticTokenBridge())
                return false;
            // Ensure source and destination tokens are equivalent, if destination is set
            const { source, destination } = this.request;
            if (destination && (0, sdk_definitions_1.isTokenId)(destination.id)) {
                // If destination token was provided, check that it's the equivalent one for the source token
                let equivalentToken = await tokenTransfer_1.TokenTransfer.lookupDestinationToken(this.request.fromChain, this.request.toChain, source.id);
                if (!(0, sdk_definitions_1.isSameToken)(equivalentToken, destination.id)) {
                    return false;
                }
            }
        }
        catch (e) {
            return false;
        }
        return true;
    }
    async isAvailable() {
        const atb = await this.request.fromChain.getAutomaticTokenBridge();
        if ((0, sdk_definitions_1.isTokenId)(this.request.source.id)) {
            return await atb.isRegisteredToken(this.request.source.id.address);
        }
        return true;
    }
    async validate(params) {
        try {
            const options = params.options ?? this.getDefaultOptions();
            const { destination } = this.request;
            let nativeGasPerc = options.nativeGas ?? 0.0;
            if (nativeGasPerc > 1.0 || nativeGasPerc < 0.0)
                throw new Error("Native gas must be between 0.0 and 1.0 (0% and 100%)");
            // If destination is native, max out the nativeGas requested
            if (destination && destination.id === "native" && nativeGasPerc === 0.0)
                nativeGasPerc = 1.0;
            const validatedParams = {
                amount: params.amount,
                options: { ...params.options, nativeGas: nativeGasPerc },
                normalizedParams: await this.normalizeTransferParams(params),
            };
            return { valid: true, params: validatedParams };
        }
        catch (e) {
            return { valid: false, params, error: e };
        }
    }
    async normalizeTransferParams(params) {
        const amount = this.request.normalizeAmount(params.amount);
        const inputToken = this.request.source.id === "native"
            ? await this.request.fromChain.getNativeWrappedTokenId()
            : this.request.source.id;
        const atb = await this.request.fromChain.getAutomaticTokenBridge();
        const fee = await atb.getRelayerFee(this.request.from.address, this.request.to, inputToken.address);
        // Min amount is fee + 5%
        const minAmount = (fee * 105n) / 100n;
        if (amount < minAmount) {
            throw new Error(`Minimum amount is ${this.request.displayAmount(amount)}`);
        }
        const transferableAmount = amount - fee;
        const { destination } = this.request;
        const options = params.options ?? this.getDefaultOptions();
        let nativeGasPerc = options.nativeGas ?? 0.0;
        // If destination is native, max out the nativeGas requested
        if (destination && destination.id === "native" && nativeGasPerc === 0.0)
            nativeGasPerc = 1.0;
        if (nativeGasPerc > 1.0 || nativeGasPerc < 0.0) {
            throw new Error("Native gas must be between 0.0 and 1.0 (0% and 100%)");
        }
        // Determine nativeGas
        let nativeGasAmount = 0n;
        if (nativeGasPerc > 0) {
            // TODO: currently supporting 2 decimals of the percentage requested
            const scale = 10000;
            const scaledGas = BigInt(options.nativeGas * scale);
            nativeGasAmount = (transferableAmount * scaledGas) / BigInt(scale);
        }
        return { fee, amount, nativeGasAmount };
    }
    async quote(params) {
        return await tokenTransfer_1.TokenTransfer.quoteTransfer(this.request.fromChain, this.request.toChain, this.toTransferDetails(params));
    }
    async initiate(signer, params) {
        const transfer = this.toTransferDetails(params);
        const txids = await tokenTransfer_1.TokenTransfer.transfer(this.request.fromChain, transfer, signer);
        const msg = await tokenTransfer_1.TokenTransfer.getTransferMessage(this.request.fromChain, txids[txids.length - 1].txid);
        return {
            from: transfer.from.chain,
            to: transfer.to.chain,
            state: types_1.TransferState.SourceFinalized,
            originTxs: txids,
            attestation: { id: msg },
        };
    }
    async *track(receipt, timeout) {
        yield* tokenTransfer_1.TokenTransfer.track(this.wh, receipt, timeout, this.request.fromChain, this.request.toChain);
    }
    toTransferDetails(params) {
        const transfer = {
            automatic: true,
            from: this.request.from,
            to: this.request.to,
            amount: params.normalizedParams.amount,
            token: this.request.source.id,
            nativeGas: params.normalizedParams.nativeGasAmount,
        };
        return transfer;
    }
}
exports.AutomaticTokenBridgeRoute = AutomaticTokenBridgeRoute;
//# sourceMappingURL=automatic.js.map