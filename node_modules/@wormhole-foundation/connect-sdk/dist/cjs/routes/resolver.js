"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouteResolver = void 0;
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const route_1 = require("./route");
class RouteResolver {
    wh;
    routeConstructors;
    inputTokenList;
    constructor(wh, routeConstructors) {
        this.wh = wh;
        this.routeConstructors = routeConstructors;
    }
    async supportedSourceTokens(chain) {
        // TODO: make this a set to dedupe?
        this.inputTokenList =
            this.inputTokenList ??
                (await Promise.all(this.routeConstructors.flatMap(async (rc) => rc.supportedSourceTokens(chain)))).flat();
        return this.inputTokenList;
    }
    async supportedDestinationTokens(inputToken, fromChain, toChain) {
        const [, inputTokenId] = (0, sdk_definitions_1.resolveWrappedToken)(fromChain.network, fromChain.chain, inputToken);
        const tokens = await Promise.all(this.routeConstructors.map(async (rc) => rc.supportedDestinationTokens(inputTokenId, fromChain, toChain)));
        return tokens.flat();
    }
    async findRoutes(request) {
        const matches = await Promise.all(this.routeConstructors
            .filter((rc) => rc.supportedNetworks().includes(this.wh.network) &&
            rc.supportedChains(this.wh.network).includes(request.to.chain) &&
            rc.supportedChains(this.wh.network).includes(request.from.chain) &&
            rc.isProtocolSupported(request.fromChain, request.toChain))
            .map((rc) => new rc(this.wh, request))
            .map(async (route) => {
            const match = (0, route_1.isAutomatic)(route) ? await route.isAvailable() : true;
            return [match, match ? route : undefined];
        }));
        return matches.filter(([match]) => match).map(([, route]) => route);
    }
    async sortRoutes(routes, sortBy) {
        // TODO: actually sort
        return routes;
    }
}
exports.RouteResolver = RouteResolver;
//# sourceMappingURL=resolver.js.map