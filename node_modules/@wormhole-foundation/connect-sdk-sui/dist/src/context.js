"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiContext = void 0;
const sui_js_1 = require("@mysten/sui.js");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const contracts_1 = require("./contracts");
const utils_2 = require("./utils");
/**
 * @category Sui
 */
class SuiContext extends connect_sdk_1.RelayerAbstract {
    constructor(wormholeInstance) {
        super();
        this.type = connect_sdk_1.Context.SUI;
        this.wormhole = wormholeInstance;
        const connection = this.wormhole.conf.rpcs.sui;
        if (connection === undefined)
            throw new Error('no connection');
        this.provider = new sui_js_1.JsonRpcProvider(new sui_js_1.Connection({ fullnode: connection }));
        this.contracts = new contracts_1.SuiContracts(this.wormhole, this.provider);
    }
    async getCoins(coinType, owner) {
        let coins = [];
        let cursor = null;
        do {
            const result = await this.provider.getCoins({
                owner,
                coinType,
                cursor,
            });
            coins = [...coins, ...result.data];
            cursor = result.hasNextPage ? result.nextCursor : null;
        } while (cursor);
        return coins;
    }
    async innerSend(token, amount, sendingChain, senderAddress, recipientChain, recipientAddress, relayerFee, payload) {
        const destContext = this.wormhole.getContext(recipientChain);
        const recipientChainId = this.wormhole.toChainId(recipientChain);
        const relayerFeeBigInt = relayerFee ? BigInt(relayerFee) : undefined;
        const amountBigInt = ethers_1.BigNumber.from(amount).toBigInt();
        let recipientAccount = recipientAddress;
        // get token account for solana
        if (recipientChainId === connect_sdk_1.MAINNET_CHAINS.solana) {
            let tokenId = token;
            if (token === connect_sdk_1.NATIVE) {
                tokenId = {
                    address: sui_js_1.SUI_TYPE_ARG,
                    chain: 'sui',
                };
            }
            recipientAccount = await this.wormhole.getSolanaRecipientAddress(recipientChain, tokenId, recipientAddress);
        }
        const formattedRecipientAccount = (0, utils_1.arrayify)(destContext.formatAddress(recipientAccount));
        let coinType;
        if (token === connect_sdk_1.NATIVE) {
            coinType = sui_js_1.SUI_TYPE_ARG;
        }
        else {
            coinType = await this.mustGetForeignAsset(token, sendingChain);
        }
        const coins = await this.getCoins(coinType, senderAddress);
        const { core, token_bridge } = this.wormhole.mustGetContracts('sui');
        if (!core || !token_bridge)
            throw new Error('contracts not found');
        const tx = await (0, utils_2.transferFromSui)(this.provider, core, token_bridge, coins, coinType, amountBigInt, recipientChainId, formattedRecipientAccount, BigInt(0), // TODO: wormhole fee
        relayerFeeBigInt, payload);
        return tx;
    }
    async startTransfer(token, amount, sendingChain, senderAddress, recipientChain, recipientAddress, relayerFee) {
        return this.innerSend(token, amount, sendingChain, senderAddress, recipientChain, recipientAddress, relayerFee);
    }
    async startTransferWithPayload(token, amount, sendingChain, senderAddress, recipientChain, recipientAddress, payload) {
        return this.innerSend(token, amount, sendingChain, senderAddress, recipientChain, recipientAddress, undefined, payload);
    }
    formatAddress(address) {
        if (!(0, sui_js_1.isValidSuiAddress)(address)) {
            throw new Error(`can't format an invalid sui address: ${address}`);
        }
        // valid sui addresses are already 32 bytes, hex prefixed
        return (0, utils_1.arrayify)(address);
    }
    parseAddress(address) {
        if (!(0, sui_js_1.isValidSuiAddress)(address)) {
            throw new Error(`can't parse an invalid sui address: ${address}`);
        }
        // valid sui addresses are already 32 bytes, hex prefixed
        return address;
    }
    /**
     * @param address The asset's address (the Sui `CoinType`)
     * @returns The external address associated with the asset address
     */
    async formatAssetAddress(address) {
        try {
            const { token_bridge } = this.contracts.mustGetContracts('sui');
            if (!token_bridge)
                throw new Error('token bridge contract not found');
            // this will throw if the asset hasn't been attested
            const { assetAddress } = await (0, utils_2.getOriginalAssetSui)(this.provider, token_bridge, address);
            return assetAddress;
        }
        catch (e) {
            console.error(`formatAssetAddress - error: ${e}`);
            throw e;
        }
    }
    /**
     * @param address The asset's external address
     * @returns The asset's address (the Sui `CoinType`) associated with the external address
     */
    async parseAssetAddress(address) {
        try {
            const { token_bridge } = this.contracts.mustGetContracts('sui');
            if (!token_bridge)
                throw new Error('token bridge contract not found');
            const coinType = await (0, utils_2.getForeignAsset)(this.provider, token_bridge, this.wormhole.toChainId('sui'), (0, utils_1.arrayify)(address));
            if (coinType === null) {
                throw new Error('coinType is null');
            }
            return coinType;
        }
        catch (e) {
            console.error(`parseAssetAddress - error: ${e}`);
            throw e;
        }
    }
    async getForeignAsset(tokenId, chain) {
        try {
            const chainId = this.wormhole.toChainId(tokenId.chain);
            const toChainId = this.wormhole.toChainId(chain);
            if (toChainId === chainId)
                return tokenId.address;
            const { token_bridge } = this.contracts.mustGetContracts('sui');
            if (!token_bridge)
                throw new Error('token bridge contract not found');
            const tokenContext = this.wormhole.getContext(tokenId.chain);
            const formattedAddr = await tokenContext.formatAssetAddress(tokenId.address);
            const coinType = await (0, utils_2.getForeignAsset)(this.provider, token_bridge, chainId, (0, utils_1.arrayify)(formattedAddr));
            return coinType;
        }
        catch (e) {
            console.log(`getForeignAsset - error: ${e}`);
            throw e;
        }
    }
    async mustGetForeignAsset(tokenId, chain) {
        const coinType = await this.getForeignAsset(tokenId, chain);
        if (!coinType)
            throw new Error('token not registered');
        return coinType;
    }
    async fetchTokenDecimals(tokenAddr, chain) {
        const metadata = await this.provider.getCoinMetadata({
            coinType: tokenAddr,
        });
        if (metadata === null) {
            throw new Error(`Can't fetch decimals for token ${tokenAddr}`);
        }
        return metadata.decimals;
    }
    async parseMessageFromTx(tx, chain) {
        const txBlock = await this.provider.getTransactionBlock({
            digest: tx,
            options: { showEvents: true, showEffects: true, showInput: true },
        });
        const message = txBlock.events?.find((event) => event.type.endsWith('WormholeMessage'));
        if (!message || !message.parsedJson) {
            throw new Error('WormholeMessage not found');
        }
        const { payload, sender: emitterAddress, sequence } = message.parsedJson;
        const parsed = (0, connect_sdk_1.parseTokenTransferPayload)(Buffer.from(payload));
        const tokenContext = this.wormhole.getContext(parsed.tokenChain);
        const destContext = this.wormhole.getContext(parsed.toChain);
        const tokenAddress = await tokenContext.parseAssetAddress((0, utils_1.hexlify)(parsed.tokenAddress));
        const tokenChain = this.wormhole.toChainName(parsed.tokenChain);
        const gasFee = (0, sui_js_1.getTotalGasUsed)(txBlock);
        const parsedMessage = {
            sendTx: tx,
            sender: (0, sui_js_1.getTransactionSender)(txBlock) || '',
            amount: ethers_1.BigNumber.from(parsed.amount),
            payloadID: parsed.payloadType,
            recipient: destContext.parseAddress((0, utils_1.hexlify)(parsed.to)),
            toChain: this.wormhole.toChainName(parsed.toChain),
            fromChain: this.wormhole.toChainName(chain),
            tokenAddress,
            tokenChain,
            tokenId: {
                chain: tokenChain,
                address: tokenAddress,
            },
            sequence: ethers_1.BigNumber.from(sequence),
            emitterAddress,
            block: Number(txBlock.checkpoint || ''),
            gasFee: gasFee ? ethers_1.BigNumber.from(gasFee) : undefined,
        };
        if (parsed.payloadType === 3) {
            const relayerPayload = destContext.parseRelayerPayload(Buffer.from(parsed.tokenTransferPayload));
            const relayerMessage = {
                ...parsedMessage,
                relayerFee: relayerPayload.relayerFee,
                relayerPayloadId: parsed.payloadType,
                to: relayerPayload.to,
                toNativeTokenAmount: relayerPayload.toNativeTokenAmount,
            };
            return [relayerMessage];
        }
        return [parsedMessage];
    }
    async getNativeBalance(walletAddress, chain) {
        const { totalBalance } = await this.provider.getBalance({
            owner: walletAddress,
        });
        return ethers_1.BigNumber.from(totalBalance);
    }
    async getTokenBalance(walletAddress, tokenId, chain) {
        const coinType = await this.getForeignAsset(tokenId, chain);
        if (!coinType)
            return null;
        const { totalBalance } = await this.provider.getBalance({
            owner: walletAddress,
            coinType,
        });
        return ethers_1.BigNumber.from(totalBalance);
    }
    async completeTransfer(destChain, signedVAA, overrides, payerAddr) {
        const { core, token_bridge } = this.contracts.mustGetContracts('sui');
        if (!core || !token_bridge)
            throw new Error('contracts not found');
        const tx = await (0, utils_2.redeemOnSui)(this.provider, core, token_bridge, signedVAA);
        return tx;
    }
    async isTransferCompleted(destChain, signedVaa) {
        const { token_bridge } = this.contracts.mustGetContracts('sui');
        if (!token_bridge)
            throw new Error('token bridge contract not found');
        return await (0, utils_2.getIsTransferCompleted)(this.provider, token_bridge, (0, utils_1.arrayify)(signedVaa));
    }
    async startTransferWithRelay(token, amount, toNativeToken, sendingChain, senderAddress, recipientChain, recipientAddress, overrides) {
        const destContext = this.wormhole.getContext(recipientChain);
        const recipientChainId = this.wormhole.toChainId(recipientChain);
        const amountBigInt = ethers_1.BigNumber.from(amount).toBigInt();
        const toNativeTokenBigInt = ethers_1.BigNumber.from(toNativeToken).toBigInt();
        let recipientAccount = recipientAddress;
        // get token account for solana
        if (recipientChainId === connect_sdk_1.MAINNET_CHAINS.solana) {
            let tokenId = token;
            if (token === connect_sdk_1.NATIVE) {
                tokenId = {
                    address: sui_js_1.SUI_TYPE_ARG,
                    chain: 'sui',
                };
            }
            recipientAccount = await this.wormhole.getSolanaRecipientAddress(recipientChain, tokenId, recipientAddress);
        }
        const formattedRecipientAccount = `0x${Buffer.from((0, utils_1.arrayify)(destContext.formatAddress(recipientAccount))).toString('hex')}`;
        let coinType;
        if (token === connect_sdk_1.NATIVE) {
            coinType = sui_js_1.SUI_TYPE_ARG;
        }
        else {
            coinType = await this.mustGetForeignAsset(token, sendingChain);
        }
        const coins = await this.getCoins(coinType, senderAddress);
        const [primaryCoin, ...mergeCoins] = coins.filter((coin) => coin.coinType === coinType);
        if (primaryCoin === undefined) {
            throw new Error(`Coins array doesn't contain any coins of type ${coinType}`);
        }
        const { core, token_bridge, relayer, suiRelayerPackageId } = this.wormhole.mustGetContracts('sui');
        if (!core || !token_bridge || !relayer || !suiRelayerPackageId)
            throw new Error('contracts not found');
        const coreBridgePackageId = await (0, utils_2.getPackageId)(this.provider, core);
        if (!coreBridgePackageId)
            throw new Error('unable to get core bridge package id');
        const tokenBridgePackageId = await (0, utils_2.getPackageId)(this.provider, token_bridge);
        if (!tokenBridgePackageId)
            throw new Error('unable to get token bridge package id');
        const tx = new sui_js_1.TransactionBlock();
        const feeAmount = BigInt(0); // TODO: wormhole fee
        const [feeCoin] = tx.splitCoins(tx.gas, [tx.pure(feeAmount)]);
        const [transferCoin] = (() => {
            if (coinType === sui_js_1.SUI_TYPE_ARG) {
                return tx.splitCoins(tx.gas, [tx.pure(amountBigInt)]);
            }
            else {
                const primaryCoinInput = tx.object(primaryCoin.coinObjectId);
                if (mergeCoins.length) {
                    tx.mergeCoins(primaryCoinInput, mergeCoins.map((coin) => tx.object(coin.coinObjectId)));
                }
                return tx.splitCoins(primaryCoinInput, [tx.pure(amountBigInt)]);
            }
        })();
        const [assetInfo] = tx.moveCall({
            target: `${tokenBridgePackageId}::state::verified_asset`,
            arguments: [tx.object(token_bridge)],
            typeArguments: [coinType],
        });
        const [transferTicket] = tx.moveCall({
            target: `${suiRelayerPackageId}::transfer::transfer_tokens_with_relay`,
            arguments: [
                tx.object(relayer),
                transferCoin,
                assetInfo,
                tx.pure(toNativeTokenBigInt),
                tx.pure(recipientChainId),
                tx.pure(formattedRecipientAccount),
                tx.pure(117),
            ],
            typeArguments: [coinType],
        });
        const [messageTicket] = tx.moveCall({
            target: `${tokenBridgePackageId}::transfer_tokens_with_payload::transfer_tokens_with_payload`,
            arguments: [tx.object(token_bridge), transferTicket],
            typeArguments: [coinType],
        });
        tx.moveCall({
            target: `${coreBridgePackageId}::publish_message::publish_message`,
            arguments: [
                tx.object(core),
                feeCoin,
                messageTicket,
                tx.object(sui_js_1.SUI_CLOCK_OBJECT_ID),
            ],
        });
        return tx;
    }
    async calculateNativeTokenAmt(destChain, tokenId, amount, walletAddress) {
        const relayer = this.contracts.mustGetTokenBridgeRelayer('sui');
        const coinType = await this.mustGetForeignAsset(tokenId, destChain);
        const nativeTokenAmount = await relayer.calculateNativeSwapAmountOut(walletAddress, coinType, amount);
        return nativeTokenAmount;
    }
    async calculateMaxSwapAmount(destChain, tokenId, walletAddress) {
        const relayer = this.contracts.mustGetTokenBridgeRelayer('sui');
        const coinType = await this.mustGetForeignAsset(tokenId, destChain);
        const maxSwap = await relayer.calculateMaxSwapAmountIn(walletAddress, coinType);
        return maxSwap;
    }
    async getRelayerFee(sourceChain, destChain, tokenId) {
        const relayer = this.contracts.mustGetTokenBridgeRelayer('sui');
        const address = await this.mustGetForeignAsset(tokenId, sourceChain);
        const decimals = await this.fetchTokenDecimals(address, sourceChain);
        const destChainId = this.wormhole.toChainId(destChain);
        const fee = await relayer.calculateRelayerFee(destChainId, address, decimals);
        return fee;
    }
    async getCurrentBlock() {
        if (!this.provider)
            throw new Error('no provider');
        const sequence = await this.provider.getLatestCheckpointSequenceNumber();
        return Number(sequence);
    }
}
exports.SuiContext = SuiContext;
//# sourceMappingURL=context.js.map