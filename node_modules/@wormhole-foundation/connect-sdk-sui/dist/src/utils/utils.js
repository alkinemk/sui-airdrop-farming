"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trimSuiType = exports.padSuiType = exports.isValidSuiType = exports.isValidSuiAddress = exports.isSuiError = exports.isSameType = exports.getWrappedCoinType = exports.getUpgradeCapObjectId = exports.getTokenFromTokenRegistry = exports.getTokenCoinType = exports.getTableKeyType = exports.getPackageIdFromType = exports.getPackageId = exports.getOwnedObjectIdPaginated = exports.getOwnedObjectId = exports.getOriginalPackageId = exports.getObjectFields = exports.getInnerType = exports.getFieldsFromObjectResponse = exports.getEmitterAddressAndSequenceFromResponseSui = exports.executeTransactionBlock = exports.uint8ArrayToBCS = void 0;
const sui_js_1 = require("@mysten/sui.js");
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const error_1 = require("./error");
const MAX_PURE_ARGUMENT_SIZE = 16 * 1024;
const UPGRADE_CAP_TYPE = '0x2::package::UpgradeCap';
const uint8ArrayToBCS = (arr) => sui_js_1.builder.ser('vector<u8>', arr, { maxSize: MAX_PURE_ARGUMENT_SIZE }).toBytes();
exports.uint8ArrayToBCS = uint8ArrayToBCS;
const executeTransactionBlock = async (signer, transactionBlock) => {
    // Let caller handle parsing and logging info
    transactionBlock.setGasBudget(100000000);
    return signer.signAndExecuteTransactionBlock({
        transactionBlock,
        options: {
            showInput: true,
            showEffects: true,
            showEvents: true,
            showObjectChanges: true,
        },
    });
};
exports.executeTransactionBlock = executeTransactionBlock;
// TODO: can we pass in the latest core bridge package Id after an upgrade?
// or do we have to use the first one?
// this is the same type that the guardian will look for
const getEmitterAddressAndSequenceFromResponseSui = (originalCoreBridgePackageId, response) => {
    const wormholeMessageEventType = `${originalCoreBridgePackageId}::publish_message::WormholeMessage`;
    const event = response.events?.find((e) => (0, exports.isSameType)(e.type, wormholeMessageEventType));
    if (event === undefined) {
        throw new Error(`${wormholeMessageEventType} event type not found`);
    }
    const { sender, sequence } = event.parsedJson || {};
    if (sender === undefined || sequence === undefined) {
        throw new Error("Can't find sender or sequence");
    }
    return { emitterAddress: sender.substring(2), sequence };
};
exports.getEmitterAddressAndSequenceFromResponseSui = getEmitterAddressAndSequenceFromResponseSui;
const getFieldsFromObjectResponse = (object) => {
    const content = object.data?.content;
    return content && content.dataType === 'moveObject' ? content.fields : null;
};
exports.getFieldsFromObjectResponse = getFieldsFromObjectResponse;
const getInnerType = (type) => {
    if (!type)
        return null;
    const match = type.match(/<(.*)>/);
    if (!match || !(0, exports.isValidSuiType)(match[1])) {
        return null;
    }
    return match[1];
};
exports.getInnerType = getInnerType;
const getObjectFields = async (provider, objectId) => {
    if (!(0, exports.isValidSuiAddress)(objectId)) {
        throw new Error(`Invalid object ID: ${objectId}`);
    }
    const res = await provider.getObject({
        id: objectId,
        options: {
            showContent: true,
        },
    });
    return (0, exports.getFieldsFromObjectResponse)(res);
};
exports.getObjectFields = getObjectFields;
const getOriginalPackageId = async (provider, stateObjectId) => {
    return (0, sui_js_1.getObjectType)(await provider.getObject({
        id: stateObjectId,
        options: { showContent: true },
    }))?.split('::')[0];
};
exports.getOriginalPackageId = getOriginalPackageId;
const getOwnedObjectId = async (provider, owner, type) => {
    // Upgrade caps are a special case
    if ((0, exports.isSameType)(type, UPGRADE_CAP_TYPE)) {
        throw new Error('`getOwnedObjectId` should not be used to get the object ID of an `UpgradeCap`. Use `getUpgradeCapObjectId` instead.');
    }
    try {
        const res = await provider.getOwnedObjects({
            owner,
            filter: { StructType: type },
            options: {
                showContent: true,
            },
        });
        if (!res || !res.data) {
            throw new error_1.SuiRpcValidationError(res);
        }
        const objects = res.data.filter((o) => o.data?.objectId);
        if (objects.length === 1) {
            return objects[0].data?.objectId ?? null;
        }
        else if (objects.length > 1) {
            const objectsStr = JSON.stringify(objects, null, 2);
            throw new Error(`Found multiple objects owned by ${owner} of type ${type}. This may mean that we've received an unexpected response from the Sui RPC and \`worm\` logic needs to be updated to handle this. Objects: ${objectsStr}`);
        }
        else {
            return null;
        }
    }
    catch (error) {
        // Handle 504 error by using findOwnedObjectByType method
        const is504HttpError = `${error}`.includes('504 Gateway Time-out');
        if (error && is504HttpError) {
            return (0, exports.getOwnedObjectIdPaginated)(provider, owner, type);
        }
        else {
            throw error;
        }
    }
};
exports.getOwnedObjectId = getOwnedObjectId;
const getOwnedObjectIdPaginated = async (provider, owner, type, cursor) => {
    const res = await provider.getOwnedObjects({
        owner,
        filter: undefined,
        cursor: cursor || undefined,
        options: {
            showType: true,
        },
    });
    if (!res || !res.data) {
        throw new error_1.SuiRpcValidationError(res);
    }
    const object = res.data.find((d) => (0, exports.isSameType)(d.data?.type || '', type));
    if (!object && res.hasNextPage) {
        return (0, exports.getOwnedObjectIdPaginated)(provider, owner, type, res.nextCursor);
    }
    else if (!object && !res.hasNextPage) {
        return null;
    }
    else {
        return object?.data?.objectId ?? null;
    }
};
exports.getOwnedObjectIdPaginated = getOwnedObjectIdPaginated;
/**
 * @param provider
 * @param objectId Core or token bridge state object ID
 * @returns The latest package ID for the provided state object
 */
async function getPackageId(provider, objectId) {
    let currentPackage;
    let nextCursor;
    do {
        const dynamicFields = await provider.getDynamicFields({
            parentId: objectId,
            cursor: nextCursor,
        });
        currentPackage = dynamicFields.data.find((field) => field.name.type.endsWith('CurrentPackage'));
        nextCursor = dynamicFields.hasNextPage ? dynamicFields.nextCursor : null;
    } while (nextCursor && !currentPackage);
    if (!currentPackage) {
        throw new Error('CurrentPackage not found');
    }
    const fields = await (0, exports.getObjectFields)(provider, currentPackage.objectId);
    const packageId = fields?.value?.fields?.package;
    if (!packageId) {
        throw new Error('Unable to get current package');
    }
    return packageId;
}
exports.getPackageId = getPackageId;
const getPackageIdFromType = (type) => {
    if (!(0, exports.isValidSuiType)(type))
        return null;
    const packageId = type.split('::')[0];
    if (!(0, exports.isValidSuiAddress)(packageId))
        return null;
    return packageId;
};
exports.getPackageIdFromType = getPackageIdFromType;
const getTableKeyType = (tableType) => {
    if (!tableType)
        return null;
    const match = (0, exports.trimSuiType)(tableType).match(/0x2::table::Table<(.*)>/);
    if (!match)
        return null;
    const [keyType] = match[1].split(',');
    if (!(0, exports.isValidSuiType)(keyType))
        return null;
    return keyType;
};
exports.getTableKeyType = getTableKeyType;
const getTokenCoinType = async (provider, tokenBridgeStateObjectId, tokenAddress, tokenChain) => {
    const tokenBridgeStateFields = await (0, exports.getObjectFields)(provider, tokenBridgeStateObjectId);
    if (!tokenBridgeStateFields) {
        throw new Error('Unable to fetch object fields from token bridge state');
    }
    const coinTypes = tokenBridgeStateFields?.token_registry?.fields?.coin_types;
    const coinTypesObjectId = coinTypes?.fields?.id?.id;
    if (!coinTypesObjectId) {
        throw new Error('Unable to fetch coin types');
    }
    const keyType = (0, exports.getTableKeyType)(coinTypes?.type);
    if (!keyType) {
        throw new Error('Unable to get key type');
    }
    const response = await provider.getDynamicFieldObject({
        parentId: coinTypesObjectId,
        name: {
            type: keyType,
            value: {
                addr: [...tokenAddress],
                chain: tokenChain,
            },
        },
    });
    if (response.error) {
        if (response.error.code === 'dynamicFieldNotFound') {
            return null;
        }
        throw new Error(`Unexpected getDynamicFieldObject response ${response.error}`);
    }
    const fields = (0, exports.getFieldsFromObjectResponse)(response);
    return fields?.value ? (0, exports.trimSuiType)((0, connect_sdk_1.ensureHexPrefix)(fields.value)) : null;
};
exports.getTokenCoinType = getTokenCoinType;
const getTokenFromTokenRegistry = async (provider, tokenBridgeStateObjectId, tokenType) => {
    if (!(0, exports.isValidSuiType)(tokenType)) {
        throw new Error(`Invalid Sui type: ${tokenType}`);
    }
    const tokenBridgeStateFields = await (0, exports.getObjectFields)(provider, tokenBridgeStateObjectId);
    if (!tokenBridgeStateFields) {
        throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${tokenBridgeStateObjectId}`);
    }
    const tokenRegistryObjectId = tokenBridgeStateFields.token_registry?.fields?.id?.id;
    if (!tokenRegistryObjectId) {
        throw new Error('Unable to fetch token registry object ID');
    }
    const tokenRegistryPackageId = (0, exports.getPackageIdFromType)(tokenBridgeStateFields.token_registry?.type);
    if (!tokenRegistryObjectId) {
        throw new Error('Unable to fetch token registry package ID');
    }
    return provider.getDynamicFieldObject({
        parentId: tokenRegistryObjectId,
        name: {
            type: `${tokenRegistryPackageId}::token_registry::Key<${tokenType}>`,
            value: {
                dummy_field: false,
            },
        },
    });
};
exports.getTokenFromTokenRegistry = getTokenFromTokenRegistry;
/**
 * This function returns the object ID of the `UpgradeCap` that belongs to the
 * given package and owner if it exists.
 *
 * Structs created by the Sui framework such as `UpgradeCap`s all have the same
 * type (e.g. `0x2::package::UpgradeCap`) and have a special field, `package`,
 * we can use to differentiate them.
 * @param provider Sui RPC provider
 * @param owner Address of the current owner of the `UpgradeCap`
 * @param packageId ID of the package that the `UpgradeCap` was created for
 * @returns The object ID of the `UpgradeCap` if it exists, otherwise `null`
 */
const getUpgradeCapObjectId = async (provider, owner, packageId) => {
    const res = await provider.getOwnedObjects({
        owner,
        filter: { StructType: (0, exports.padSuiType)(UPGRADE_CAP_TYPE) },
        options: {
            showContent: true,
        },
    });
    if (!res || !res.data) {
        throw new error_1.SuiRpcValidationError(res);
    }
    const objects = res.data.filter((o) => o.data?.objectId &&
        o.data?.content?.dataType === 'moveObject' &&
        (0, sui_js_1.normalizeSuiAddress)(o.data?.content?.fields?.package) ===
            (0, sui_js_1.normalizeSuiAddress)(packageId));
    if (objects.length === 1) {
        // We've found the object we're looking for
        return objects[0].data?.objectId ?? null;
    }
    else if (objects.length > 1) {
        const objectsStr = JSON.stringify(objects, null, 2);
        throw new Error(`Found multiple upgrade capabilities owned by ${owner} from package ${packageId}. Objects: ${objectsStr}`);
    }
    else {
        return null;
    }
};
exports.getUpgradeCapObjectId = getUpgradeCapObjectId;
/**
 * Get the fully qualified type of a wrapped asset published to the given
 * package ID.
 *
 * All wrapped assets that are registered with the token bridge must satisfy
 * the requirement that module name is `coin` (source: https://github.com/wormhole-foundation/wormhole/blob/a1b3773ee42507122c3c4c3494898fbf515d0712/sui/token_bridge/sources/create_wrapped.move#L88).
 * As a result, all wrapped assets share the same module name and struct name,
 * since the struct name is necessarily `COIN` since it is a OTW.
 * @param coinPackageId packageId of the wrapped asset
 * @returns Fully qualified type of the wrapped asset
 */
const getWrappedCoinType = (coinPackageId) => {
    if (!(0, exports.isValidSuiAddress)(coinPackageId)) {
        throw new Error(`Invalid package ID: ${coinPackageId}`);
    }
    return `${coinPackageId}::coin::COIN`;
};
exports.getWrappedCoinType = getWrappedCoinType;
const isSameType = (a, b) => {
    try {
        return (0, exports.trimSuiType)(a) === (0, exports.trimSuiType)(b);
    }
    catch (e) {
        return false;
    }
};
exports.isSameType = isSameType;
const isSuiError = (error) => {
    return (error && typeof error === 'object' && 'code' in error && 'message' in error);
};
exports.isSuiError = isSuiError;
/**
 * This method validates any Sui address, even if it's not 32 bytes long, i.e.
 * "0x2". This differs from Mysten's implementation, which requires that the
 * given address is 32 bytes long.
 * @param address Address to check
 * @returns If given address is a valid Sui address or not
 */
const isValidSuiAddress = (address) => (0, sui_js_1.isValidSuiAddress)((0, sui_js_1.normalizeSuiAddress)(address));
exports.isValidSuiAddress = isValidSuiAddress;
const isValidSuiType = (type) => {
    const tokens = type.split('::');
    if (tokens.length !== 3) {
        return false;
    }
    return (0, exports.isValidSuiAddress)(tokens[0]) && !!tokens[1] && !!tokens[2];
};
exports.isValidSuiType = isValidSuiType;
/**
 * Unlike `trimSuiType`, this method does not modify nested types, it just pads
 * the top-level type.
 * @param type
 * @returns
 */
const padSuiType = (type) => {
    const tokens = type.split('::');
    if (tokens.length < 3 || !(0, exports.isValidSuiAddress)(tokens[0])) {
        throw new Error(`Invalid Sui type: ${type}`);
    }
    return [(0, sui_js_1.normalizeSuiAddress)(tokens[0]), ...tokens.slice(1)].join('::');
};
exports.padSuiType = padSuiType;
/**
 * This method removes leading zeroes for types in order to normalize them
 * since some types returned from the RPC have leading zeroes and others don't.
 */
const trimSuiType = (type) => type.replace(/(0x)(0*)/g, '0x');
exports.trimSuiType = trimSuiType;
//# sourceMappingURL=utils.js.map