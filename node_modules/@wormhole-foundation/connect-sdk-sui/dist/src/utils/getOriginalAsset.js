"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOriginalAssetSui = void 0;
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const utils_1 = require("./utils");
async function getOriginalAssetSui(provider, tokenBridgeStateObjectId, coinType) {
    if (!(0, utils_1.isValidSuiType)(coinType)) {
        throw new Error(`Invalid Sui type: ${coinType}`);
    }
    const res = await (0, utils_1.getTokenFromTokenRegistry)(provider, tokenBridgeStateObjectId, coinType);
    const fields = (0, utils_1.getFieldsFromObjectResponse)(res);
    if (!fields) {
        throw new Error(`Token of type ${coinType} has not been registered with the token bridge`);
    }
    // Normalize types
    const type = (0, utils_1.trimSuiType)(fields.value.type);
    coinType = (0, utils_1.trimSuiType)(coinType);
    // Check if wrapped or native asset. We check inclusion instead of equality
    // because it saves us from making an additional RPC call to fetch the
    // package ID.
    if (type.includes(`wrapped_asset::WrappedAsset<${coinType}>`)) {
        return {
            isWrapped: true,
            chainId: Number(fields.value.fields.info.fields.token_chain),
            assetAddress: new Uint8Array(fields.value.fields.info.fields.token_address.fields.value.fields.data),
        };
    }
    else if (type.includes(`native_asset::NativeAsset<${coinType}>`)) {
        return {
            isWrapped: false,
            chainId: connect_sdk_1.MAINNET_CHAINS.sui,
            assetAddress: new Uint8Array(fields.value.fields.token_address.fields.value.fields.data),
        };
    }
    throw new Error(`Unrecognized token metadata: ${JSON.stringify(fields, null, 2)}, ${coinType}`);
}
exports.getOriginalAssetSui = getOriginalAssetSui;
//# sourceMappingURL=getOriginalAsset.js.map