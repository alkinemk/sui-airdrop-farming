"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferFromSui = void 0;
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const sui_js_1 = require("@mysten/sui.js");
const utils_1 = require("./utils");
async function transferFromSui(provider, coreBridgeStateObjectId, tokenBridgeStateObjectId, coins, coinType, amount, recipientChainId, recipient, feeAmount = BigInt(0), relayerFee = BigInt(0), payload = null, coreBridgePackageId, tokenBridgePackageId) {
    if (payload !== null) {
        throw new Error('Sui transfer with payload not implemented');
    }
    const [primaryCoin, ...mergeCoins] = coins.filter((coin) => (0, utils_1.isSameType)(coin.coinType, coinType));
    if (primaryCoin === undefined) {
        throw new Error(`Coins array doesn't contain any coins of type ${coinType}`);
    }
    [coreBridgePackageId, tokenBridgePackageId] = await Promise.all([
        coreBridgePackageId
            ? Promise.resolve(coreBridgePackageId)
            : (0, utils_1.getPackageId)(provider, coreBridgeStateObjectId),
        tokenBridgePackageId
            ? Promise.resolve(tokenBridgePackageId)
            : (0, utils_1.getPackageId)(provider, tokenBridgeStateObjectId),
    ]);
    const tx = new sui_js_1.TransactionBlock();
    const [transferCoin] = (() => {
        if (coinType === sui_js_1.SUI_TYPE_ARG) {
            return tx.splitCoins(tx.gas, [tx.pure(amount)]);
        }
        else {
            const primaryCoinInput = tx.object(primaryCoin.coinObjectId);
            if (mergeCoins.length) {
                tx.mergeCoins(primaryCoinInput, mergeCoins.map((coin) => tx.object(coin.coinObjectId)));
            }
            return tx.splitCoins(primaryCoinInput, [tx.pure(amount)]);
        }
    })();
    const [feeCoin] = tx.splitCoins(tx.gas, [tx.pure(feeAmount)]);
    const [assetInfo] = tx.moveCall({
        target: `${tokenBridgePackageId}::state::verified_asset`,
        arguments: [tx.object(tokenBridgeStateObjectId)],
        typeArguments: [coinType],
    });
    const [transferTicket, dust] = tx.moveCall({
        target: `${tokenBridgePackageId}::transfer_tokens::prepare_transfer`,
        arguments: [
            assetInfo,
            transferCoin,
            tx.pure(recipientChainId),
            tx.pure([...recipient]),
            tx.pure(relayerFee),
            tx.pure((0, connect_sdk_1.createNonce)().readUInt32LE()),
        ],
        typeArguments: [coinType],
    });
    tx.moveCall({
        target: `${tokenBridgePackageId}::coin_utils::return_nonzero`,
        arguments: [dust],
        typeArguments: [coinType],
    });
    const [messageTicket] = tx.moveCall({
        target: `${tokenBridgePackageId}::transfer_tokens::transfer_tokens`,
        arguments: [tx.object(tokenBridgeStateObjectId), transferTicket],
        typeArguments: [coinType],
    });
    tx.moveCall({
        target: `${coreBridgePackageId}::publish_message::publish_message`,
        arguments: [
            tx.object(coreBridgeStateObjectId),
            feeCoin,
            messageTicket,
            tx.object(sui_js_1.SUI_CLOCK_OBJECT_ID),
        ],
    });
    return tx;
}
exports.transferFromSui = transferFromSui;
//# sourceMappingURL=transfer.js.map