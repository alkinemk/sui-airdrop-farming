"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.redeemOnSui = void 0;
const sui_js_1 = require("@mysten/sui.js");
const utils_1 = require("./utils");
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
async function redeemOnSui(provider, coreBridgeStateObjectId, tokenBridgeStateObjectId, transferVAA, coreBridgePackageId, tokenBridgePackageId) {
    const { tokenAddress, tokenChain } = (0, connect_sdk_1.parseTokenTransferVaa)(transferVAA);
    const coinType = await (0, utils_1.getTokenCoinType)(provider, tokenBridgeStateObjectId, tokenAddress, tokenChain);
    if (!coinType) {
        throw new Error('Unable to fetch token coinType');
    }
    [coreBridgePackageId, tokenBridgePackageId] = await Promise.all([
        coreBridgePackageId
            ? Promise.resolve(coreBridgePackageId)
            : (0, utils_1.getPackageId)(provider, coreBridgeStateObjectId),
        tokenBridgePackageId
            ? Promise.resolve(tokenBridgePackageId)
            : (0, utils_1.getPackageId)(provider, tokenBridgeStateObjectId),
    ]);
    const tx = new sui_js_1.TransactionBlock();
    const [verifiedVAA] = tx.moveCall({
        target: `${coreBridgePackageId}::vaa::parse_and_verify`,
        arguments: [
            tx.object(coreBridgeStateObjectId),
            tx.pure((0, utils_1.uint8ArrayToBCS)(transferVAA)),
            tx.object(sui_js_1.SUI_CLOCK_OBJECT_ID),
        ],
    });
    const [tokenBridgeMessage] = tx.moveCall({
        target: `${tokenBridgePackageId}::vaa::verify_only_once`,
        arguments: [tx.object(tokenBridgeStateObjectId), verifiedVAA],
    });
    const [relayerReceipt] = tx.moveCall({
        target: `${tokenBridgePackageId}::complete_transfer::authorize_transfer`,
        arguments: [tx.object(tokenBridgeStateObjectId), tokenBridgeMessage],
        typeArguments: [coinType],
    });
    const [coins] = tx.moveCall({
        target: `${tokenBridgePackageId}::complete_transfer::redeem_relayer_payout`,
        arguments: [relayerReceipt],
        typeArguments: [coinType],
    });
    tx.moveCall({
        target: `${tokenBridgePackageId}::coin_utils::return_nonzero`,
        arguments: [coins],
        typeArguments: [coinType],
    });
    return tx;
}
exports.redeemOnSui = redeemOnSui;
//# sourceMappingURL=redeem.js.map