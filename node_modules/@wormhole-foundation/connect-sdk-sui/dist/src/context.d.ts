import { JsonRpcProvider, TransactionBlock } from '@mysten/sui.js';
import { BigNumber, BigNumberish } from 'ethers';
import { ChainId, ChainName, Context, NATIVE, ParsedMessage, ParsedRelayerMessage, TokenId, Wormhole, RelayerAbstract } from '@wormhole-foundation/connect-sdk';
import { SuiContracts } from './contracts';
/**
 * @category Sui
 */
export declare class SuiContext extends RelayerAbstract<TransactionBlock> {
    readonly type = Context.SUI;
    readonly contracts: SuiContracts;
    protected wormhole: Wormhole;
    readonly provider: JsonRpcProvider;
    constructor(wormholeInstance: Wormhole);
    getCoins(coinType: string, owner: string): Promise<{
        coinType: string;
        coinObjectId: string;
    }[]>;
    innerSend(token: TokenId | typeof NATIVE, amount: bigint, sendingChain: ChainName | ChainId, senderAddress: string, recipientChain: ChainName | ChainId, recipientAddress: string, relayerFee: any, payload?: Uint8Array | undefined): Promise<TransactionBlock>;
    startTransfer(token: TokenId | typeof NATIVE, amount: bigint, sendingChain: ChainName | ChainId, senderAddress: string, recipientChain: ChainName | ChainId, recipientAddress: string, relayerFee: any): Promise<TransactionBlock>;
    startTransferWithPayload(token: TokenId | typeof NATIVE, amount: bigint, sendingChain: ChainName | ChainId, senderAddress: string, recipientChain: ChainName | ChainId, recipientAddress: string, payload: Uint8Array | undefined): Promise<TransactionBlock>;
    formatAddress(address: string): Uint8Array;
    parseAddress(address: string): string;
    /**
     * @param address The asset's address (the Sui `CoinType`)
     * @returns The external address associated with the asset address
     */
    formatAssetAddress(address: string): Promise<Uint8Array>;
    /**
     * @param address The asset's external address
     * @returns The asset's address (the Sui `CoinType`) associated with the external address
     */
    parseAssetAddress(address: string): Promise<string>;
    getForeignAsset(tokenId: TokenId, chain: ChainName | ChainId): Promise<string | null>;
    mustGetForeignAsset(tokenId: TokenId, chain: ChainName | ChainId): Promise<string>;
    fetchTokenDecimals(tokenAddr: string, chain: ChainName | ChainId): Promise<number>;
    parseMessageFromTx(tx: string, chain: ChainName | ChainId): Promise<ParsedMessage[] | ParsedRelayerMessage[]>;
    getNativeBalance(walletAddress: string, chain: ChainName | ChainId): Promise<BigNumber>;
    getTokenBalance(walletAddress: string, tokenId: TokenId, chain: ChainName | ChainId): Promise<BigNumber | null>;
    completeTransfer(destChain: ChainName | ChainId, signedVAA: Uint8Array, overrides: any, payerAddr?: any): Promise<TransactionBlock>;
    isTransferCompleted(destChain: ChainName | ChainId, signedVaa: string): Promise<boolean>;
    startTransferWithRelay(token: TokenId | 'native', amount: bigint, toNativeToken: string, sendingChain: ChainName | ChainId, senderAddress: string, recipientChain: ChainName | ChainId, recipientAddress: string, overrides?: any): Promise<TransactionBlock>;
    calculateNativeTokenAmt(destChain: ChainName | ChainId, tokenId: TokenId, amount: BigNumberish, walletAddress: string): Promise<BigNumber>;
    calculateMaxSwapAmount(destChain: ChainName | ChainId, tokenId: TokenId, walletAddress: string): Promise<BigNumber>;
    getRelayerFee(sourceChain: ChainName | ChainId, destChain: ChainName | ChainId, tokenId: TokenId): Promise<BigNumber>;
    getCurrentBlock(): Promise<number>;
}
