import { chainToPlatform, platformToAddressFormat, } from "@wormhole-foundation/sdk-base";
//TODO BRRRR circular include!!
//I have yet to figure out how to get the equivalent of a forward declaration to work (without
//  yet again having to rely on global scope...)
//I first tried `declare class UniversalAddress {};` but this actually introduces a new, separate
//  type in this module rather than telling the compiler that we already have this type elsewhere
//I could also create an interface via `interface IUnverisalAddress {}` but that seems like an
//  even worse solution, as is just throwing everything into this file here and just brushing
//  things under the rug by not separating them out.
import { UniversalAddress } from "./universalAddress";
const nativeFactory = new Map();
export function registerNative(platform, ctr) {
    if (nativeFactory.has(platform)) {
        console.warn("Native address type for platform %s has already registered", platform);
        //throw new Error(`Native address type for platform ${platform} has already registered`);
        return;
    }
    nativeFactory.set(platform, ctr);
}
export function nativeIsRegistered(chain) {
    const platform = chainToPlatform.get(chain);
    return nativeFactory.has(platform);
}
export function toNative(chain, ua) {
    const platform = chainToPlatform.get(chain);
    const nativeCtr = nativeFactory.get(platform);
    if (!nativeCtr)
        throw new Error(`No native address type registered for platform ${platform}`);
    return new nativeCtr(ua);
}
export function toUniversal(chain, address) {
    const platform = chainToPlatform.get(chain);
    return new UniversalAddress(address, platformToAddressFormat.get(platform));
}
//# sourceMappingURL=address.js.map