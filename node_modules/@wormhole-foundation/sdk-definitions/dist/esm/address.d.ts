import { Chain, ChainToPlatform, Platform } from "@wormhole-foundation/sdk-base";
import { UniversalAddress } from "./universalAddress";
export interface Address {
    unwrap(): unknown;
    toString(): string;
    toUint8Array(): Uint8Array;
    toUniversalAddress(): UniversalAddress;
}
declare global {
    namespace WormholeNamespace {
        interface PlatformToNativeAddressMapping {
        }
    }
}
export type MappedPlatforms = keyof WormholeNamespace.PlatformToNativeAddressMapping;
type GetNativeAddress<T extends Platform> = T extends MappedPlatforms ? WormholeNamespace.PlatformToNativeAddressMapping[T] : never;
export type NativeAddress<C extends Chain> = GetNativeAddress<ChainToPlatform<C>>;
export type UniversalOrNative<T extends Chain> = UniversalAddress | NativeAddress<T>;
export type AccountAddress<T extends Chain> = UniversalOrNative<T>;
export type TokenAddress<T extends Chain> = UniversalOrNative<T> | "native";
export type ChainAddress<C extends Chain = Chain> = {
    readonly chain: C;
    readonly address: UniversalOrNative<C>;
};
type NativeAddressCtr = new (ua: UniversalAddress | string | Uint8Array) => Address;
export declare function registerNative<P extends Platform>(platform: P, ctr: NativeAddressCtr): void;
export declare function nativeIsRegistered<C extends Chain>(chain: C): boolean;
export declare function toNative<C extends Chain>(chain: C, ua: UniversalAddress | string | Uint8Array): NativeAddress<C>;
export declare function toUniversal<C extends Chain>(chain: C, address: string | Uint8Array): UniversalAddress;
export {};
//# sourceMappingURL=address.d.ts.map