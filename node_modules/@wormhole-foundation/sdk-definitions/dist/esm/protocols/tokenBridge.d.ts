import { Chain, Network, Platform, PlatformToChains } from "@wormhole-foundation/sdk-base";
import { AccountAddress, ChainAddress, NativeAddress, TokenAddress, UniversalOrNative } from "../address";
import "../payloads/tokenBridge";
import "../payloads/automaticTokenBridge";
import { TokenId } from "../types";
import { UnsignedTransaction } from "../unsignedTransaction";
import { ProtocolPayload, ProtocolVAA } from "../vaa";
export declare const ErrNotWrapped: (token: string) => Error;
export declare namespace TokenBridge {
    const _protocol = "TokenBridge";
    export type ProtocolName = typeof _protocol;
    const _transferPayloads: readonly ["Transfer", "TransferWithPayload"];
    const _attestPayloads: readonly ["AttestMeta"];
    const _payloads: readonly ["Transfer", "TransferWithPayload", "AttestMeta"];
    export type TransferPayloadNames = (typeof _transferPayloads)[number];
    export type AttestPayloadNames = (typeof _attestPayloads)[number];
    export type PayloadNames = (typeof _payloads)[number];
    export type TransferVAA<PayloadName extends TransferPayloadNames = TransferPayloadNames> = ProtocolVAA<ProtocolName, PayloadName>;
    export type AttestVAA<PayloadName extends AttestPayloadNames = AttestPayloadNames> = ProtocolVAA<ProtocolName, PayloadName>;
    export type VAA<PayloadName extends PayloadNames = PayloadNames> = ProtocolVAA<ProtocolName, PayloadName>;
    export type TransferPayload<PayloadName extends TransferPayloadNames = TransferPayloadNames> = ProtocolPayload<ProtocolName, PayloadName>;
    export type AttestPayload<PayloadName extends AttestPayloadNames = AttestPayloadNames> = ProtocolPayload<ProtocolName, PayloadName>;
    export type Payload<PayloadName extends PayloadNames = PayloadNames> = ProtocolPayload<ProtocolName, PayloadName>;
    export const getTransferDiscriminator: () => import("../vaa").PayloadDiscriminator<"TokenBridge:Transfer" | "TokenBridge:TransferWithPayload", false>;
    export {};
}
export declare namespace AutomaticTokenBridge {
    const _protocol = "AutomaticTokenBridge";
    export type ProtocolName = typeof _protocol;
    const _payloads: readonly ["TransferWithRelay"];
    export type PayloadNames = (typeof _payloads)[number];
    export type VAA<PayloadName extends PayloadNames = PayloadNames> = ProtocolVAA<ProtocolName, PayloadName>;
    export type Payload<PayloadName extends PayloadNames = PayloadNames> = ProtocolPayload<ProtocolName, PayloadName>;
    export {};
}
export type TokenTransferDetails = {
    token: TokenId | "native";
    amount: bigint;
    from: ChainAddress;
    to: ChainAddress;
    automatic?: boolean;
    payload?: Uint8Array;
    nativeGas?: bigint;
};
export declare function isTokenTransferDetails(thing: TokenTransferDetails | any): thing is TokenTransferDetails;
export interface TokenBridge<N extends Network, P extends Platform, C extends PlatformToChains<P>> {
    isWrappedAsset(nativeAddress: TokenAddress<C>): Promise<boolean>;
    getOriginalAsset(nativeAddress: TokenAddress<C>): Promise<TokenId<Chain>>;
    getWrappedNative(): Promise<NativeAddress<C>>;
    hasWrappedAsset(foreignToken: TokenId<Chain>): Promise<boolean>;
    getWrappedAsset(foreignToken: TokenId<Chain>): Promise<NativeAddress<C>>;
    isTransferCompleted(vaa: TokenBridge.TransferVAA): Promise<boolean>;
    createAttestation(token: TokenAddress<C>, payer?: UniversalOrNative<C>): AsyncGenerator<UnsignedTransaction<N, C>>;
    submitAttestation(vaa: TokenBridge.AttestVAA, payer?: UniversalOrNative<C>): AsyncGenerator<UnsignedTransaction<N, C>>;
    transfer(sender: AccountAddress<C>, recipient: ChainAddress, token: TokenAddress<C>, amount: bigint, payload?: Uint8Array): AsyncGenerator<UnsignedTransaction<N, C>>;
    redeem(sender: AccountAddress<C>, vaa: TokenBridge.TransferVAA, unwrapNative?: boolean): AsyncGenerator<UnsignedTransaction<N, C>>;
}
export interface AutomaticTokenBridge<N extends Network, P extends Platform, C extends PlatformToChains<P>> {
    transfer(sender: AccountAddress<C>, recipient: ChainAddress, token: TokenAddress<C>, amount: bigint, nativeGas?: bigint): AsyncGenerator<UnsignedTransaction<N, C>>;
    redeem(sender: AccountAddress<C>, vaa: AutomaticTokenBridge.VAA): AsyncGenerator<UnsignedTransaction<N, C>>;
    getRelayerFee(sender: AccountAddress<C>, recipient: ChainAddress, token: TokenAddress<C>): Promise<bigint>;
    isRegisteredToken(token: TokenAddress<C>): Promise<boolean>;
    getRegisteredTokens(): Promise<NativeAddress<C>[]>;
    nativeTokenAmount(token: TokenAddress<C>, amount: bigint): Promise<bigint>;
    maxSwapAmount(token: TokenAddress<C>): Promise<bigint>;
}
//# sourceMappingURL=tokenBridge.d.ts.map