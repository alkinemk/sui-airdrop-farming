import { Chain, LayoutToType, Network, Platform, PlatformToChains } from "@wormhole-foundation/sdk-base";
import { AccountAddress, ChainAddress } from "../address";
import { CircleMessageId } from "../attestation";
import { TokenId } from "../types";
import { UnsignedTransaction } from "../unsignedTransaction";
import "../payloads/automaticCircleBridge";
import { circleMessageLayout } from "../payloads/circleBridge";
import { ProtocolPayload, ProtocolVAA } from "../vaa";
export declare namespace CircleBridge {
    const _protocol = "CircleBridge";
    export type ProtocolName = typeof _protocol;
    const _payloads: readonly ["Message"];
    export type PayloadNames = (typeof _payloads)[number];
    export type Message = LayoutToType<typeof circleMessageLayout>;
    export type Attestation = {
        message: Message;
        attestation?: string;
    };
    export const deserialize: (data: Uint8Array) => [CircleBridge.Message, string];
    export const serialize: (msg: CircleBridge.Message) => Uint8Array;
    export {};
}
export declare namespace AutomaticCircleBridge {
    const _protocol = "AutomaticCircleBridge";
    export type ProtocolName = typeof _protocol;
    const _payloads: readonly ["DepositWithPayload", "TransferWithRelay"];
    export type PayloadNames = (typeof _payloads)[number];
    export type VAA<PayloadName extends PayloadNames = PayloadNames> = ProtocolVAA<ProtocolName, PayloadName>;
    export type Payload<PayloadName extends PayloadNames = PayloadNames> = ProtocolPayload<ProtocolName, PayloadName>;
    export const getTransferDiscriminator: () => import("../vaa").PayloadDiscriminator<"AutomaticCircleBridge:TransferWithRelay" | "AutomaticCircleBridge:DepositWithPayload", false>;
    export {};
}
export type CircleTransferMessage = {
    from: ChainAddress;
    to: ChainAddress;
    token: TokenId;
    amount: bigint;
    message: CircleBridge.Message;
    id: CircleMessageId;
};
export type CircleTransferDetails = {
    amount: bigint;
    from: ChainAddress;
    to: ChainAddress;
    automatic?: boolean;
    payload?: Uint8Array;
    nativeGas?: bigint;
};
export declare function isCircleTransferDetails(thing: any): thing is CircleTransferDetails;
export interface CircleBridge<N extends Network, P extends Platform, C extends PlatformToChains<P>> {
    redeem(sender: AccountAddress<C>, message: CircleBridge.Message, attestation: string): AsyncGenerator<UnsignedTransaction<N, C>>;
    transfer(sender: AccountAddress<C>, recipient: ChainAddress, amount: bigint): AsyncGenerator<UnsignedTransaction<N, C>>;
    isTransferCompleted(message: CircleBridge.Message): Promise<boolean>;
    parseTransactionDetails(txid: string): Promise<CircleTransferMessage>;
}
export interface AutomaticCircleBridge<N extends Network, P extends Platform, C extends Chain = PlatformToChains<P>> {
    getRelayerFee(destination: Chain): Promise<bigint>;
    transfer(sender: AccountAddress<C>, recipient: ChainAddress, amount: bigint, nativeGas?: bigint): AsyncGenerator<UnsignedTransaction<N, C>>;
}
//# sourceMappingURL=circleBridge.d.ts.map