import { LayoutToType } from "@wormhole-foundation/sdk-base";
import { LayoutLiteral, PayloadLiteral, LayoutOf, ProtocolName, ComposeLiteral } from "./registration";
export type LayoutLiteralToPayload<LL extends LayoutLiteral> = LayoutToType<LayoutOf<LL>>;
export type Payload<PL extends PayloadLiteral> = PL extends LayoutLiteral ? LayoutLiteralToPayload<PL> : Uint8Array;
export type DecomposeLiteral<PL extends PayloadLiteral> = PL extends `${infer Protocol}:${infer LayoutName}` ? [Protocol, LayoutName] : [null, PL];
export declare function decomposeLiteral<PL extends PayloadLiteral>(payloadLiteral: PL): DecomposeLiteral<PL>;
export declare const headerLayout: readonly [{
    readonly name: "version";
    readonly binary: "uint";
    readonly size: 1;
    readonly custom: 1;
    readonly omit: true;
}, {
    readonly binary: "uint";
    readonly size: 4;
    readonly name: "guardianSet";
}, {
    readonly name: "signatures";
    readonly binary: "array";
    readonly lengthSize: 1;
    readonly layout: readonly [{
        readonly name: "guardianIndex";
        readonly binary: "uint";
        readonly size: 1;
    }, {
        readonly binary: "bytes";
        readonly size: 65;
        readonly custom: {
            readonly to: (val: Uint8Array) => import("..").Signature;
            readonly from: (val: import("..").Signature) => Uint8Array;
        };
        readonly name: "signature";
    }];
}];
export declare const envelopeLayout: readonly [{
    readonly name: "timestamp";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly name: "nonce";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly custom: {
        to: (val: number) => "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Base" | "Sei" | "Rootstock" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky";
        from: (val: "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Base" | "Sei" | "Rootstock" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky") => number;
    };
    readonly binary: "uint";
    readonly size: 2;
    readonly name: "emitterChain";
}, {
    readonly binary: "bytes";
    readonly size: 32;
    readonly custom: {
        to: (val: Uint8Array) => import("..").UniversalAddress;
        from: (val: import("..").UniversalAddress) => Uint8Array;
    };
    readonly name: "emitterAddress";
}, {
    readonly binary: "uint";
    readonly size: 8;
    readonly name: "sequence";
}, {
    readonly name: "consistencyLevel";
    readonly binary: "uint";
    readonly size: 1;
}];
export declare const baseLayout: readonly [{
    readonly name: "version";
    readonly binary: "uint";
    readonly size: 1;
    readonly custom: 1;
    readonly omit: true;
}, {
    readonly binary: "uint";
    readonly size: 4;
    readonly name: "guardianSet";
}, {
    readonly name: "signatures";
    readonly binary: "array";
    readonly lengthSize: 1;
    readonly layout: readonly [{
        readonly name: "guardianIndex";
        readonly binary: "uint";
        readonly size: 1;
    }, {
        readonly binary: "bytes";
        readonly size: 65;
        readonly custom: {
            readonly to: (val: Uint8Array) => import("..").Signature;
            readonly from: (val: import("..").Signature) => Uint8Array;
        };
        readonly name: "signature";
    }];
}, {
    readonly name: "timestamp";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly name: "nonce";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly custom: {
        to: (val: number) => "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Base" | "Sei" | "Rootstock" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky";
        from: (val: "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Base" | "Sei" | "Rootstock" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky") => number;
    };
    readonly binary: "uint";
    readonly size: 2;
    readonly name: "emitterChain";
}, {
    readonly binary: "bytes";
    readonly size: 32;
    readonly custom: {
        to: (val: Uint8Array) => import("..").UniversalAddress;
        from: (val: import("..").UniversalAddress) => Uint8Array;
    };
    readonly name: "emitterAddress";
}, {
    readonly binary: "uint";
    readonly size: 8;
    readonly name: "sequence";
}, {
    readonly name: "consistencyLevel";
    readonly binary: "uint";
    readonly size: 1;
}];
type VAABase = LayoutToType<typeof baseLayout>;
export interface VAA<PL extends PayloadLiteral = PayloadLiteral> extends VAABase {
    readonly protocolName: DecomposeLiteral<PL>[0];
    readonly payloadName: DecomposeLiteral<PL>[1];
    readonly payloadLiteral: PL;
    readonly payload: Payload<PL>;
    readonly hash: Uint8Array;
}
export type DistributiveVAA<PL extends PayloadLiteral> = PL extends PayloadLiteral ? VAA<PL> : never;
export type ProtocolVAA<PN extends ProtocolName, PayloadName extends string> = ComposeLiteral<PN, PayloadName, PayloadLiteral> extends infer PL extends PayloadLiteral ? DistributiveVAA<PL> : never;
export type DistributivePayload<PL extends PayloadLiteral> = PL extends PayloadLiteral ? Payload<PL> : never;
export type ProtocolPayload<PN extends ProtocolName, PayloadName extends string> = ComposeLiteral<PN, PayloadName, PayloadLiteral> extends infer PL extends PayloadLiteral ? DistributivePayload<PL> : never;
export {};
//# sourceMappingURL=vaa.d.ts.map