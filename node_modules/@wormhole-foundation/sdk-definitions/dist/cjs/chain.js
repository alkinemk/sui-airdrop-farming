"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainContext = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const address_1 = require("./address");
const protocol_1 = require("./protocol");
class ChainContext {
    network;
    platform;
    chain;
    config;
    // Cached Protocol clients
    rpc;
    coreBridge;
    tokenBridge;
    autoTokenBridge;
    circleBridge;
    autoCircleBridge;
    ibcBridge;
    constructor(chain, platform, rpc) {
        this.config = platform.config[chain];
        this.platform = platform;
        this.chain = this.config.key;
        this.network = this.config.network;
        this.rpc = rpc;
    }
    getRpc() {
        this.rpc = this.rpc ? this.rpc : this.platform.getRpc(this.chain);
        return this.rpc;
    }
    // Get the number of decimals for a token
    async getDecimals(token) {
        // try to find it in the token cache first
        if (this.config.tokenMap) {
            const found = sdk_base_1.tokens.getTokenByAddress(this.network, this.chain, token.toString());
            if (found)
                return BigInt(found.decimals);
        }
        return this.platform.utils().getDecimals(this.chain, this.getRpc(), token);
    }
    // Get the balance of a token for a given address
    async getBalance(walletAddr, token) {
        return this.platform.utils().getBalance(this.chain, await this.getRpc(), walletAddr, token);
    }
    async getLatestBlock() {
        return this.platform.utils().getLatestBlock(this.getRpc());
    }
    async getLatestFinalizedBlock() {
        return this.platform.utils().getLatestFinalizedBlock(this.getRpc());
    }
    // Get details about the transaction
    async parseTransaction(txid) {
        return this.platform.parseWormholeMessages(this.chain, await this.getRpc(), txid);
    }
    // Send a transaction and wait for it to be confirmed
    async sendWait(stxns) {
        return this.platform.utils().sendWait(this.chain, await this.getRpc(), stxns);
    }
    getToken(symbol) {
        if (!this.config.tokenMap)
            return;
        if (!(symbol in this.config.tokenMap))
            return;
        return this.config.tokenMap[symbol];
    }
    async getNativeWrappedTokenId() {
        // see if we have it configured
        if (this.config.wrappedNative) {
            const { address } = this.config.wrappedNative;
            return { chain: this.chain, address: (0, address_1.toNative)(this.chain, address) };
        }
        // otherwise grab it from the token bridge fn
        const tb = await this.getTokenBridge();
        return { chain: this.chain, address: await tb.getWrappedNative() };
    }
    // Get the token account for a given address
    async getTokenAccount(address, token) {
        // Noop by default, override in implementation if necessary
        return { chain: this.chain, address };
    }
    //
    // protocols
    //
    //
    supportsProtocol(protocolName) {
        return (0, protocol_1.protocolIsRegistered)(this.chain, protocolName);
    }
    supportsWormholeCore = () => this.supportsProtocol("WormholeCore");
    async getWormholeCore() {
        this.coreBridge = this.coreBridge
            ? this.coreBridge
            : await this.platform.getProtocol("WormholeCore", await this.getRpc());
        return this.coreBridge;
    }
    supportsTokenBridge = () => this.supportsProtocol("TokenBridge");
    async getTokenBridge() {
        this.tokenBridge = this.tokenBridge
            ? this.tokenBridge
            : await this.platform.getProtocol("TokenBridge", await this.getRpc());
        return this.tokenBridge;
    }
    //
    supportsAutomaticTokenBridge = () => this.supportsProtocol("AutomaticTokenBridge");
    async getAutomaticTokenBridge() {
        this.autoTokenBridge = this.autoTokenBridge
            ? this.autoTokenBridge
            : await this.platform.getProtocol("AutomaticTokenBridge", await this.getRpc());
        return this.autoTokenBridge;
    }
    //
    supportsCircleBridge = () => this.supportsProtocol("CircleBridge");
    async getCircleBridge() {
        this.circleBridge = this.circleBridge
            ? this.circleBridge
            : await this.platform.getProtocol("CircleBridge", await this.getRpc());
        return this.circleBridge;
    }
    //
    supportsAutomaticCircleBridge = () => this.supportsProtocol("AutomaticCircleBridge");
    async getAutomaticCircleBridge() {
        this.autoCircleBridge = this.autoCircleBridge
            ? this.autoCircleBridge
            : await this.platform.getProtocol("AutomaticCircleBridge", await this.getRpc());
        return this.autoCircleBridge;
    }
    //
    supportsIbcBridge = () => this.supportsProtocol("IbcBridge");
    async getIbcBridge() {
        this.ibcBridge = this.ibcBridge
            ? this.ibcBridge
            : await this.platform.getProtocol("IbcBridge", await this.getRpc());
        return this.ibcBridge;
    }
}
exports.ChainContext = ChainContext;
//# sourceMappingURL=chain.js.map