import { Chain, Network, Platform, ProtocolName } from "@wormhole-foundation/sdk-base";
import { RpcConnection } from "./rpc";
import { ChainsConfig } from "./types";
declare global {
    namespace WormholeNamespace {
        interface PlatformToProtocolMapping {
        }
    }
}
type MappedProtocolPlatforms = keyof WormholeNamespace.PlatformToProtocolMapping;
type MappedProtocols = keyof WormholeNamespace.PlatformToProtocolMapping[MappedProtocolPlatforms];
export type ProtocolImplementation<T extends Platform, PN extends ProtocolName> = T extends MappedProtocolPlatforms ? PN extends MappedProtocols ? WormholeNamespace.PlatformToProtocolMapping[T][PN] : any : never;
export interface ProtocolInitializer<P extends Platform, PN extends ProtocolName> {
    fromRpc(rpc: RpcConnection<P>, config: ChainsConfig<Network, P>): Promise<ProtocolImplementation<P, PN>>;
}
export declare function registerProtocol<P extends Platform, PN extends ProtocolName>(platform: P, protocol: PN, ctr: ProtocolInitializer<P, PN>): void;
export declare function protocolIsRegistered<T extends Platform | Chain, PN extends ProtocolName>(chainOrPlatform: T, protocol: PN): boolean;
export declare function getProtocolInitializer<P extends Platform, PN extends ProtocolName>(platform: P, protocol: PN): ProtocolInitializer<P, PN>;
export declare const create: <N extends "Mainnet" | "Testnet" | "Devnet", P extends "Evm" | "Solana" | "Cosmwasm" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near", PN extends "TokenBridge" | "AutomaticTokenBridge" | "AutomaticCircleBridge" | "CircleBridge" | "Relayer" | "WormholeCore" | "IbcBridge" | "NftBridge", T>(platform: P, protocol: PN, rpc: any, config: ChainsConfig<N, P>) => Promise<T>;
export {};
//# sourceMappingURL=protocol.d.ts.map